<?xml version="1.0" encoding="utf-8"?>
<configuration>
	<configSections>
		<section name="logConfig" type="logPrint.Config.LogPrintConfigSection, logPrint"/>
	</configSections>

	<startup>
		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8"/>
	</startup>

	<logConfig>
		<usage>
			<![CDATA[
~m~Usage:
	~M~logPrint ~B~{~c~--help~B~|~c~-?~B~|~c~-h~B~}
		~m~Prints ~M~usage~m~ and exits.
	~M~logPrint ~c~--config
		~m~Prints ~M~help on configuring~m~ and exits.
	~M~logPrint ~c~-l~B~|~c~--list
		~m~Lists the currently configured ~y~flags~m~ and ~y~ruleSets~m~ and exits.
	~M~logPrint ~Y~[~B~{~c~OPTION~y~[~y~ ~C~VALUE~y~]~B~|~M~N~G~x ~c~-f~y~[~c~q~y~] ~C~VALUE~G~=~B~}~Y~]~y~... ~Y~[~c~FILENAME~Y~] [~c~OPTION~Y~]~y~...
		~W~The ~M~logPrint~W~ tool c~Y~o~G~l~C~o~B~u~M~r~R~i~Y~s~G~e~C~s~W~ and ~Y~analyses~W~ its input according to the rules defined in its #m#App.config#!# file.  See #b#~M~logPrint ~c~--config#!#~W~ for details on how to configure it.

~m~Options:
	~C~FILENAME~M~      Read from the specified file rather than ~C~STDIN~M~.  ~Y~Only the last filename is used.
	~C~-~M~             Read from ~C~STDIN~M~ - ~y~this is the default~M~.

	~c~-a~M~            Output colours using ~W~ANSI~M~ instead of using ~c~ConsoleColor~M~.
	               ~y~Note that not all colour combinations work in ANSI mode - bright background colours cause issues.

	~c~-F~M~            Follow - do not exit at ~w~EOF~M~ but rather await more data.  ~Y~Only makes sense when not reading ~C~STDIN~Y~.
	~c~-FD~M~           Follow Directory - like Follow but if any new file of the same extension arrives in that directory, processing switches to that new file.
	               ~g~Useful for ~w~OBS~g~ which makes a new log file each time it starts.

	~c~-r ~C~SET_NAME~M~   Specify the ~r~<~R~ruleSet~r~>~M~ to activate.  The ~C~SET_NAME~M~ is tested as a prefix match.
	               ~y~If not specified, or no match, the first ruleSet defined is used.

	~c~-f ~C~SET_NAME~Y~[~c~/~C~FLAG_NAME~Y~][~G~:~C~DEFINE~y~[~G~,~C~DEFINE~y~]...~Y~][~G~=~y~[~C~ID_REGEX~y~]~Y~]
	              ~M~Specify a ~r~<~R~flagSet~r~>~M~ to apply.  ~y~This can be specified more than once, and ~C~SET_NAME~y~, ~C~FLAG_NAME~y~ and ~C~DEFINE~y~s are tested as prefix matches.
	              ~M~If the ~c~=~C~ID_REGEX~M~ is present and the ~r~<~R~flagSet~r~>~M~ defines a ~r~trackID~M~ regex, this flagSet will only respond to lines where the matched ID matches the supplied ~r~idRegex~M~.
	              ~M~if ~C~ID_REGEX~M~ is blank, the flagSet will auto-assign the first new ID and keep that, thus allowing you to do e.g.:
	                   #b#~y~... ~c~-f ~C~Conversation=~c~  -f ~C~Conversation= ~y~...#!#
	               ~M~to have 2 copies of the flagSet named ~C~Conversation~M~, where the first conversation seen will be responded to by the first copy and the 2nd one by the 2nd one.
	              If ~C~FLAG_NAME~M~ is specified, only use that, not the whole flagSet.  If ~C~DEFINE~M~s are present, they get applied to select the ~r~<~R~define~r~>~M~ values used.
	              ~Y~Note that if a blank ID is matched, the last one to record an ID responds, but does not reset its ID.
	              ~Y~When this arg is prefixed by ~M~N~G~x~Y~, it is the same as repeating this arg and it's value ~M~N~Y~ times - most useful for auto-assigned IDs.
	              ~y~Flags are reset to their ~m~initialState~y~ if the current ~r~ruleSet~y~'s ~m~reset~y~ matches.
	~c~-fq ~C~SET_NAME~Y~[~c~/~C~FLAG_NAME~Y~][~G~:~C~DEFINE~y~[~G~,~C~DEFINE~y~]...~Y~][~G~=~y~[~C~ID_REGEX~y~]~Y~]
	              ~M~Same as ~c~-f~M~ except that it adds a ~G~query trigger~M~ for the specified ~C~flagSet~y~(~M~/~C~flag~y~)~M~.

	~G~@~C~FROM_TIME~Y~[~y~[ ]~B~{~G~~~~C~TO_TIME~B~|~G~+~C~SPAN~B~}~Y~]
	              ~M~Show only lines from ~C~FROM_TIME~M~, until the end of the file, or until ~C~TO_TIME~M~ if specified, or to a calculated end time of ~C~FROM_TIME ~g~+ ~C~SPAN~M~ if specified.
	              ~Y~All other output is suppressed outside of this time range~y~, and the bounds seen are printed for convenience.

	~c~-ta~M~           Make subsequent time-deltas per adjacent log line pairs, regardles of visibility.  ~Y~This is the default.
	~c~-tt~M~           Make subsequent time-deltas per ~w~threadID~M~ log line pairs, rather than just across adjacent log line pairs.
	~c~-tv~M~           Make subsequent time-deltas per line printed, rather than across all adjacent log line pairs.
	              ~Y~These 3 ~y~(~c~-ta~y~, ~c~-tt~y~ and ~c~-tv~y~) ~Y~must be specified ~W~before~Y~ ~c~-t~Y~ or ~c~-T~Y~ to have an effect, thus allowing one of each.

	~c~-t~Y~[~C~SIZE~Y~]      ~M~Show a time-delta marker as a graph.  ~y~The default size is ~Y~6~y~.
	~c~-T            ~M~Show a time-delta marker but output the ~c~TimeSpan~M~ rather than the graph.
	~c~-tq~Y~[ ]~B~{~C~s~B~|~C~m~B~|~C~h~B~|~C~TIMESPAN~B~}~M~
	              ~M~Set a ~G~query trigger~M~ for ~r~long-duration~M~ lines, where the long means a duration larger than 1~c~(~C~h~c~|~C~m~c~|~C~s~c~)~M~ or the supplied ~C~TIMESPAN~M~.  ~y~Adds ~c~-t~y~ if not already seen.

	~c~-e~M~            Set a ~G~query trigger~M~ for lines containing ~Y~"~W~Exception~Y~"~M~.

	~c~-g ~C~REGEX~M~      Set a ~G~query trigger~M~ for lines matching ~C~REGEX~M~.  ~y~May be repeated - ~C~REGEX~c~es~y~ accumulate with ~Y~Or~y~.
	~c~-gv ~C~REGEX~M~     Set a ~G~query trigger~M~ for lines ~Y~not~M~ matching ~C~REGEX~M~.  ~y~May be repeated - ~C~REGEX~c~es~y~ accumulate with ~Y~Nor~y~.
	~c~-gV ~C~REGEX~M~     Exclude lines matching ~C~REGEX~M~.  ~y~May be repeated - ~C~REGEX~c~es~y~ accumulate with ~Y~Or~y~.  ~Y~Takes precidence over ~c~-g~Y~.

	~c~-D~M~            Pause after printing the header, to verify the args say what you want.  ~K~In the debug build, this also means launch the debugger.

	~c~-s ~C~RECORDS
	~c~-s ~C~LINES~g~L
	~c~-s ~C~TIME_STEP~M~  Pause after ~C~RECORDS~M~ records, approximately ~C~LINES~M~ lines, or after ~C~TIME_STEP~M~ time since the start or last pause.

	~c~-S ~C~TIME_STEP~Y~[~G~/~C~SCALE_FACTOR~Y~]~M~
	              Summarise the log, printing a marker for each line that falls inside each of the given ~C~TIME_STEP~M~-sized buckets.
	              If ~C~SCALE_FACTOR~M~ is supplied, scale the width of the graph down by that much.

~G~Queries~w~ suppress normal output unless a query trigger fires.
~Y~Note that more than one type of query is specified, the union of all sets of matching lines is shown.  ~y~In particular, this means specifying both ~c~-g~y~ & ~c~-gv~y~ may not do what you expect.
More likely, ~c~-gV~y~ is a better operation.
			]]>
		</usage>
		<definition>
			<![CDATA[
~m~Usage:
	~M~logPrint ~B~{~c~--help~B~|~c~-?~B~|~c~-h~B~}
		~m~Prints ~M~usage~m~ and exits.
	~M~logPrint ~c~--config
		~m~Prints ~M~help on configuring~m~ and exits.  ~Y~See below.
	~M~logPrint ~Y~[~c~OPTION~Y~]~y~... ~Y~[~c~FILENAME~Y~] [~c~OPTION~Y~]~y~...
		~W~The ~M~logPrint~W~ tool c~Y~o~G~l~C~o~B~u~M~r~R~i~Y~s~G~e~C~s~W~ and ~Y~analyses~W~ its input according to the rules defined in its #m#App.config#!# file.  See #b#~M~logPrint ~c~--help#!#~W~ for details on how to use it.

The #b#App.config#!# file ~K~(deployed as ~y~logPrint.exe.config~K~)~!~ contains a ~r~<~R~rulesConfig~r~>~!~ section:
~r~<~R~rulesConfig~r~>
	~r~<~R~usage~r~>~K~The usage documentation.~r~</~R~usage~r~>
	~r~<~R~definition~r~>~K~The config documentation.~r~</~R~definition~r~>

	~r~<~R~flagSets~r~>
		~r~<~R~flagSet ~M~name~y~="~c~NAME~y~"~r~>
			~K~<!-- ~g~Normal~K~ flag: -->
			~r~<~R~flag ~M~name~y~="~c~NAME~y~"~Y~
			      [~M~initialState~y~="~B~{~G~On~B~|~G~Off~B~|~G~TransitioningOn~B~|~G~TransitioningOff~B~}~y~"~Y~]
			      ~M~off~y~="~g~TEXT~y~"~Y~[ ~M~offMatch~y~="~C~REGEX~y~"~Y~]
			      ~M~on~y~="~g~TEXT~y~"~Y~[ ~M~onMatch~y~="~C~REGEX~y~"~Y~]
			      ~Y~[~M~toggleMatch~y~="~C~REGEX~y~"~Y~]
			      ~M~transitionToOff~y~="~g~TEXT~y~"~Y~[ ~M~transitionToOffMatch~y~="~C~REGEX~y~"~Y~]
			      ~M~transitionToOn~y~="~g~TEXT~y~"~Y~[ ~M~transitionToOnMatch~y~="~C~REGEX~y~"~Y~]
			~r~/>
			~K~<!-- or, ~c~Eval~K~ flag: -->
			~r~<~R~flag ~M~name~y~="~c~NAME~y~"~Y~
			      ~M~types~y~="#y#~B~VAR~G~=~C~TYPE~Y~[~G~;~B~VAR~G~=~C~TYPE~Y~]*#!#"~Y~
			      ~M~onMatch~y~="~C~REGEX~y~"~Y~
			      [~M~transitionToOnMatch~y~="~C~REGEX~y~"~Y~]
			~r~>
				~Y~[~r~<~R~defines>
					~r~<~R~define ~M~name~y~="~c~NAME~y~" ~M~type~y~="~C~TYPE~y~"~r~>
						~r~<~R~value ~M~name~y~="~c~NAME~y~" ~M~value~y~="~W~VALUE~y~"~r~/>~Y~*
					~r~</~R~define>~Y~*
				~r~</~R~defines>~Y~]
				~Y~[~r~<~R~consts>
					~r~<~R~const ~M~name~y~="~c~NAME~y~" ~M~type~y~="~C~TYPE~y~" ~M~value~y~="~W~VALUE~y~"~r~/>~Y~*
				~r~</~R~consts>~Y~]
				~Y~[~r~<~R~fields>
					~r~<~R~field ~M~name~y~="~c~NAME~y~" ~M~type~y~="~C~TYPE~y~" ~M~value~y~="~W~VALUE~y~"~r~/>~Y~*
				~r~</~R~fields>~Y~]
				~Y~[~r~<~R~properties>
					~r~<~R~property ~M~name~y~="~c~NAME~y~" ~M~type~y~="~C~TYPE~y~" ~M~code~y~="~W~CODE~y~"~r~/>~Y~*
				~r~</~R~properties>~Y~]
				~Y~[~r~<~R~methods>
					~r~<~R~method ~M~name~y~="~c~NAME~y~" ~M~code~y~="~W~CODE~y~"~r~/>~Y~*
				~r~</~R~methods>~Y~]

				~r~<~R~eval ~M~when~y~="~W~CODE~y~" ~M~output~y~="~g~TEXT~y~"~r~>~Y~*
				~Y~[~r~<~R~eval ~M~when~y~="~G~Else~y~" ~M~output~y~="~g~TEXT~y~"~r~/>~Y~]
			~r~</~R~flag~r~>~Y~*
		~r~</~R~flagSet~r~>~Y~*
	~r~</~R~flagSets~r~>

	~r~<~R~ruleSets~r~>
		~r~<~R~ruleSet ~M~name~y~="~c~NAME~y~"~Y~[ ~M~reset~y~="~C~REGEX~y~"~Y~]~r~>
			~Y~[~r~<~R~vars~r~>
				~r~<~R~var ~M~name~y~="~c~NAME~y~" ~M~value~y~="~g~TEXT~y~"~r~/>~Y~*
			~r~</~R~vars~r~>~Y~]

			~K~<!-- ~y~Simple~K~ rule: -->
			~r~<~R~rule ~M~name~y~="~c~NAME~y~"~Y~[ ~M~test~y~="~C~TEST_REGEX~y~"~Y~] ~M~match~y~="~C~REGEX~y~"~Y~[ ~M~parse~y~="~G~JSON~y~"~Y~] ~M~replace~y~="~g~TEXT~y~"~Y~[ ~M~repeat~y~="~G~True~y~"~Y~]~r~/>~Y~*
			~K~<!-- or, ~m~Compound~K~ rule: -->
			~r~<~R~rule ~M~name~y~="~c~NAME~y~"~Y~[ ~M~test~y~="~C~TEST_REGEX~y~"~Y~] ~M~match~y~="~C~REGEX~y~"parse~y~="~B~{~G~JSON~B~|~G~Parent~B~}~y~"~Y~] ~M~replace~y~="~g~TEXT~y~"~Y~[ ~M~repeat~y~="~G~True~y~"~Y~]~r~>
				~r~<~R~group ~M~name~y~="~c~GROUP_NAME~Y~[~G~.~c~SUFFIX~Y~]~y~"~Y~[ ~M~test~y~="~C~TEST_REGEX~y~"~Y~] ~M~match~y~="~C~REGEX~y~" ~M~replace~y~="~g~TEXT~y~"~Y~[ ~M~repeat~y~="~G~True~y~"~Y~]~r~>
					~Y~[~r~<~R~group ~Y~...[~r~/~Y~]~r~>~Y~*]
				~r~</~R~group~r~>~Y~*
			~r~</~R~rule~r~>~Y~*
		~r~</~R~ruleSet~r~>
	~r~</~R~ruleSets~r~>
~r~</~R~rulesConfig~r~>

~W~GENERAL
	~c~NAME~w~s must be unique among their siblings.
	~C~REGEX~c~es~w~ must be valid ~W~C## ~c~Regex~w~ patterns, optionally containing ~y~[~K~named~y~]~w~ groups.
	~g~TEXT~w~ can contain ~W~Colour Codes~w~ as well as normal ~W~text~w~.  ~r~<~R~rule~r~>~w~/~r~<~R~group~r~> ~M~replace ~g~TEXT~w~ can also contain ~y~%variable%~w~ references.
	~G~Other values~w~ are verbatim, case-sensitive.

~Y~FLAGS:~w~
	#g#Normal flags#!# are things that carry state forward, so are useful for tracking the lifespan of things, and state changes therein.
	They are processed by matching the lines (but not modifying them) and set their state accordingly if one of the ~M~xxxMatch ~C~REGEX~c~es ~w~matches.
	If ~M~toggleMatch~w~ matches, the state flips.
	All state transitions are allowed - no check on the current state is made.  If more than one ~C~REGEX~w~ matches on the same line, the following precidence is obeyed, from highest to lowest:
		~M~Toggle~m~:          ~G~On~M~<->~G~Off~m~, ~G~TransitionToOn~M~<->~G~TransitionToOff
		~M~TransitionToOn~m~:  ~M~-->~G~TransitionToOn
		~M~TransitionToOff~m~: ~M~-->~G~TransitionToOff
		~M~On~m~:              ~M~-->~G~On
		~M~Off~m~:             ~M~-->~G~Off
	~w~The ~g~TEXT~w~ for the current (or new) state is output every line.  A change in a flag state can be queried for using ~c~-fq~w~.

	#c#Eval flags#!# are different - they extract 1 or more named ~B~values~w~ from the matched line (by way of named groups in the ~M~onMatch ~C~REGEX~w~ and calculate a boolean result based on those,
	 using a ~W~C## expression~w~.  The ~c~Type~w~s of the ~B~values~w~ must all be declared in the ~M~types~w~ attribute.  ~Y~Note that any type used ~y~(apart from ~c~string~y~)~Y~ must have a a static ~y~Parse~K~(~c~string~K~)~Y~ method to call.
	~y~If the group did not match anything, if ~c~Type~y~ is ~c~Nullable<~C~T~c~>~y~ or ~c~string~y~, then the value is set to ~B~null~y~, otherwise it is unchanged.~w~
	If ~M~transitionToOnMatch~w~ is specified, it is used as an early bail-out - the following is skipped if its ~C~REGEX~w~ does not match, including ~G~Else~w~ processing.
	If an ~W~expression~w~ evaluates to ~B~#c#true#!#~w~, the ~M~output ~g~TEXT~w~ becomes the flag's value until the next match.
	If the ~W~expression~w~ supplied is the value ~G~Else~w~ then the ~M~output ~g~TEXT~w~ becomes the flag's value until the next match if no other ~C~REGEX~c~es~w~ matched.
	~y~(If you have a line that would signify the end of where a flag value makes sense, include matching it in ~M~transitionToOnMatch~g~ but not in ~M~onMatch~g~ to trigger the ~G~Else~g~ entry.)~w~

	~Y~Optionally~w~, other members may also be specified, and referred to in the ~r~<~R~eval~r~>~w~s ~M~code~w~ attribute:
		~r~<~R~const~r~>	    ~y~-~w~ An immutable field of the supplied ~C~TYPE~w~ with the supplied ~W~VALUE~w~.
		~r~<~R~field~r~>	    ~y~-~w~ A mutable field of the supplied ~C~TYPE~w~ with the supplied initial ~W~VALUE~w~.  ~Y~Not reset when the flag resets.
		~r~<~R~property~r~>  ~y~-~w~ A read-only calculated property of the supplied ~C~TYPE~w~ with the supplied ~W~CODE~w~.
		~r~<~R~method~r~>    ~y~-~w~ A void, parameterless method with the supplied ~W~CODE~w~, called between the flags values being set from its ~M~onMatch ~C~REGEX~w~ and its value being evaluated.
			      ~y~The method will have access to all members, including the boolean ~G~Else~y~ property, which can be used to implement any required reset logic.
		~r~<~R~define~r~>    ~y~-~w~ A compile-time constant whose value is selected from a set of possibilities via the ~G~:~C~DEFINE~y~[~G~,~C~DEFINE~y~]...~w~ part of the argument to ~c~-f~w~/~c~-fq~w~.
			      Defines are prefix-matched by ~M~name~w~, and the first is used if none match or no ~C~DEFINE~w~ value was supplied.
				  ~Y~E.g.
					#b#~y~... ~c~-f ~C~StreamHealth~G~:~Y~720~G~,~Y~60 ~y~...#!#

~Y~RULES:
	~w~If the ~r~<~R~ruleSet~r~>~w~'s ~M~reset ~C~REGEX ~w~was specified and matches the line, any ~y~flags~w~ in use (via ~c~-f~w~ or ~c~-fq~w~) are reset.

	~y~VARIABLES:~w~
		Variables are a handy way of theming the colours used, by naming them.  ~r~<~R~rule~r~> ~M~replace ~g~TEXT~w~s first have any ~y~%~g~name~y~%~w~ references replaced with the respective ~M~value ~g~TEXT~w~.

	All rules take a line and ~W~modify~w~ it by ~c~Regex~K~.~y~Replace~K~()~w~, usually used to just ~Y~c~G~o~C~l~B~o~M~u~R~r~Y~i~G~s~C~e~w~ the matched text, but can also be used to transform it.
	They first check for a match, using the ~M~test ~C~REGEX~w~, if present, otherwise using the ~M~match ~C~REGEX~w~.  No match means bail out and don't change the line.
	Then they apply the ~M~replace ~g~TEXT~w~ with the successful ~c~Match~w~ and update the line accordingly.  ~Y~Thus, order matters.  Subsequent ~r~<~R~rule~r~>~Y~s are matching against the ~W~modified~Y~ line.~w~

	If a rule is set to ~M~repeat~w~ then after it evaluates, it will re-apply itself until it no longer matches - thus such a rule can match against its own output.
	~y~Normally not needed as all matches are replaced at once if there are multiple on the line.~w~

	If a rule is set to ~M~parse ~G~JSON~w~ then several things happen:
		~Y~*~w~ The matched named group ~G~JSON~w~ if present, or the entire match otherwise, is parsed as JSON;
		~Y~*~y~ Replace strings ~c~(see below)~w~ can call ~y~JSON functions~w~ to read and manipulate the parsed JSON;
		~Y~*~w~ An extra optional set of ~y~variables~w~ are looked for to specify the colours for complex JSON values when output ~c~(see below)~w~.

	#m#Compound rules#!# extend the matching by applying a set of ~r~<~R~group~r~>~w~s (sub-rules) to a successful match's ~c~Group~w~ value.  Their input is the value of the group, and their output becomes the replace value of that group.
	~r~<~R~group~r~>~w~s under compound rules can also be compound rules, recursively.
	~Y~Note~w~ that since ~c~NAME~w~s must be unique, you can ~c~SUFFIX~w~ a name to have more than one sub match against the same group - matching only considers the ~c~NAME~w~ up to the ~G~.~w~, if present.

	If a ~r~<~R~group~r~>~w~ is set to ~M~parse ~G~JSON~w~, the same set of extra things happens as above; if it is set to ~M~parse ~G~Parent~w~ then the JSON functions apply to the parent's parsed JSON instead.

~Y~REPLACE STRINGS:~W~
	The ~M~replace~g~ TEXT~w~ can be used to reformat the matching output (e.g. to make it easier to read), and/or to ~k~#Y#c#G#o#C#l#B#~K~o~k~#M#u#R#r#Y#i#G#s#C#e#k#~!~ it via the following codes:
		~G~~~~Y~x~G~~~ ~w~means set the foreground colour to ~Y~x~w~ - see the list below for possible values of ~Y~x~w~.
		~G~##~Y~x~G~## ~w~means the same, but for the background colour.
		~G~%~g~v~G~% ~W~means insert the value of var ~g~v~w~ here.
		You can escape ~G~~~~w~ or ~G~##~w~ by doubling them.

		Normal ~c~Regex~w~ replace string rules apply:
			~Y~* ~R~$~G~1~w~, ~R~$~G~2~w~, e.t.c. represent the values of the numbered captured groups, and ~R~$~G~0~w~ means the whole match;
			~Y~* ~R~${~C~NAME~R~}~w~ represent the value of the name captured group ~C~NAME~w~;
				~Y~* ~w~If ~y~JSON functions are enabled, the group ~C~NAME~w~ can be one of:
					~R~${~G~JSON.value(~C~PATH~G~)~R~}~y~ - ~w~Read a JSON ~C~PATH~w~.
					~R~${~G~JSON.value?(~C~PATH~G~)~R~}~y~ - ~w~Read a JSON ~C~PATH~w~ but return null if it's not found.
					~R~${~G~JSON.read(~C~PATH~G~)~R~}~y~  - ~w~Read a JSON ~C~PATH~w~, and remove the leaf once read.
					~R~${~G~JSON.read?(~C~PATH~G~)~R~}~y~  - ~w~Read a JSON ~C~PATH~w~, and remove the leaf once read; return null if not found.
					~R~${~G~JSON.unread()~R~}~y~    - ~w~Output all remaining JSON as a single complex object.~y~
							      Note that complex JSON values look for extra ~y~variables~w~ for formatting options ~c~(see below)~w~.

		~y~Values for ~Y~x~y~:~W~
			! ~w~or~W~ RESET    Reset to the default colour.  Reset is not case-sensitive; all others are.
			<             Push the current colour and make no changes.
			>             Pop the last pushed colour and use that.
				      ~Y~Note that all replaces including sub group replaces are surrounded automatically by a push/pop pair for both FG and BG.~w~

			k ~w~or~W~ black    #K#~k~Black~W~#!#.      ~y~Usual default background colour.~W~
			r ~w~or~W~ red      ~r~DarkRed~W~.
			g ~w~or~W~ green    ~g~DarkGreen~W~.
			y ~w~or~W~ yellow   ~y~DarkYellow~W~.
			b ~w~or~W~ blue     ~b~DarkBlue~W~.
			m ~w~or~W~ magenta  ~m~DarkMagenta~W~.
			c ~w~or~W~ cyan     ~c~DarkCyan~W~.
			w ~w~or~W~ white    ~w~Grey~W~.       ~y~Usual default foreground colour.~W~

			K ~w~or~W~ BLACK    ~K~DargGrey~W~.
			R ~w~or~W~ RED      ~R~Red~W~.
			G ~w~or~W~ GREEN    ~G~Green~W~.
			Y ~w~or~W~ YELLOW   ~Y~Yellow~W~.
			B ~w~or~W~ BLUE     ~B~Blue~W~.
			M ~w~or~W~ MAGENTA  ~M~Magenta~W~.
			C ~w~or~W~ CYAN     ~C~Cyan~W~.
			W ~w~or~W~ WHITE    White.

		~y~Optional JSON formatting variables:~w~
			~r~<~R~var ~M~name~y~="~G~JSON.indent~y~"    ~M~value~y~="   "~r~/> ~y~-~w~ If defined, this specifies the string to use for indentation.
			~r~<~R~var ~M~name~y~="~G~JSON.prop~y~"      ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ ~C~properties~c~: value }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.:~y~"         ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ colons~C~:~c~ 0 }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.,~y~"         ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ _: commas~C~,~c~ a: [0~C~,~c~ 1] }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.{}~y~"        ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~C~{~c~ braces: 0 ~C~}~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.[]~y~"        ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~C~[~c~ brackets ~C~]~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.&quot;~y~"    ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ string: ~C~values~c~ }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.!~y~"         ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ booleans: ~C~true~c~ }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.0~y~"         ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ integer: ~C~values~c~ }~w~ (defaults to the value of ~y~%JSON.0.0%~w~);
			~r~<~R~var ~M~name~y~="~G~JSON.0.0~y~"       ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ float: ~C~values~c~ }~w~; (defaults to the value of ~y~%JSON.0%~w~);
			~r~<~R~var ~M~name~y~="~G~JSON.null~y~"      ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ nulls: ~C~null~c~ }~w~;
			~r~<~R~var ~M~name~y~="~G~JSON.undefined~y~" ~M~value~y~=""~r~/> ~y~-~w~ If defined, this specifies the colour for ~c~{ undefineds: ~C~undefined~c~ }~w~.
			]]>
		</definition>

		<flagSets>
			<flagSet name="OBS">
				<flag name="ProcessRunning" off="~K~O" offMatch="OBS Process exited" on="#Y#~K~O" onMatch="OBS Process started|OBS Process was running"/>
				<flag name="Connected" off="~K~C" offMatch="OBS Process exited" on="~G~C" onMatch="OBS WebSocket connected"/>
				<flag name="CachedScenes" off="~K~c" offMatch="EmptyScenesCache|OBS Process exited" on="#G#~K~c" onMatch="Got scenes from websocket"/>
				<flag name="StreamingRequested" off="~r~s" on="~g~s" toggleMatch="ToggleStreaming\(\) called." offMatch="Stop stuff: streaming := stop\.\.\."/>
				<flag
					name="Streaming"
					off="~r~S"
					offMatch="OnStreamingChanged\(Stopped\)|OBS Process exited"
					transitionToOn="#g#~r~S"
					transitionToOnMatch="OnStreamingChanged\(Starting\)"
					on="~G~S"
					onMatch="OnStreamingChanged\(Started\)"
					transitionToOff="#R#~g~S"
					transitionToOffMatch="OnStreamingChanged\(Stopping\)"
				/>
				<flag name="RecordingRequested" off="~r~r" on="~g~r" toggleMatch="ToggleRecording\(\) called." offMatch="Stop stuff: recording := stop\.\.\."/>
				<flag
					name="Recording"
					off="~r~R"
					offMatch="OnRecordingChanged\(Stopped\)|OBS Process exited"
					transitionToOn="#g#~r~R"
					transitionToOnMatch="OnRecordingChanged\(Starting\)"
					on="~G~R"
					onMatch="OnRecordingChanged\(Started\)"
					transitionToOff="#R#~g~R"
					transitionToOffMatch="OnRecordingChanged\(Stopping\)"
				/>
				<!--<flag name="_" initialState="On" offMatch="(?!)" on="~k~ "/>-->
			</flagSet>
			<flagSet name="60FPS">
				<flag
					name="StreamFPS"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?FPS=(?&lt;fps&gt;[^;]+)"
					types="on=bool;fps=float"
				>
					<eval when="on &amp;&amp; fps &lt;= 0.0" output="#R#~k~F"/>
					<eval when="on &amp;&amp; fps &gt;= 60.0" output="~G~#g#F"/>
					<eval when="on &amp;&amp; fps &gt; 45.0" output="~G~F"/>
					<eval when="on &amp;&amp; fps &gt; 30.0" output="~g~F"/>
					<eval when="on &amp;&amp; fps &gt; 20.0" output="~Y~F"/>
					<eval when="on &amp;&amp; fps &gt; 15.0" output="~M~F"/>
					<eval when="on &amp;&amp; fps &lt;= 15.0" output="~R~F"/>
					<eval when="Else" output="~K~F"/>
				</flag>
			</flagSet>
			<flagSet name="_60FPS">
				<flag
					name="StreamFPS"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?FPS=(?&lt;fps&gt;[^;]+)"
					types="on=bool;fps=float"
				>
					<eval when="on &amp;&amp; fps &lt;= 0.0" output="#R#~k~FPS==0.0"/>
					<eval when="on &amp;&amp; fps &gt;= 60.0" output="~G~#g#FPS&gt;=60."/>
					<eval when="on &amp;&amp; fps &gt; 55.0" output="~G~FPS&gt;55.0"/>
					<eval when="on &amp;&amp; fps &gt; 50.0" output="~g~FPS&gt;50.0"/>
					<eval when="on &amp;&amp; fps &gt; 45.0" output="~Y~FPS&gt;45.0"/>
					<eval when="on &amp;&amp; fps &gt; 40.0" output="~y~FPS&gt;40.0"/>
					<eval when="on &amp;&amp; fps &gt; 30.0" output="~M~FPS&gt;30.0"/>
					<eval when="on &amp;&amp; fps &lt;= 30.0" output="~R~FPS&lt;=30!"/>
					<eval when="Else" output="~K~--fps---"/>
				</flag>
			</flagSet>
			<flagSet name="30FPS">
				<flag
					name="StreamFPS"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?FPS=(?&lt;fps&gt;[^;]+)"
					types="on=bool;fps=float"
				>
					<eval when="on &amp;&amp; fps &lt;= 0.0" output="#R#~k~F"/>
					<eval when="on &amp;&amp; fps &gt;= 30.0" output="~G~#g#F"/>
					<eval when="on &amp;&amp; fps &gt; 22.5" output="~G~F"/>
					<eval when="on &amp;&amp; fps &gt; 15.0" output="~g~F"/>
					<eval when="on &amp;&amp; fps &gt; 10.0" output="~Y~F"/>
					<eval when="on &amp;&amp; fps &gt; 7.5" output="~M~F"/>
					<eval when="on &amp;&amp; fps &lt;= 7.5" output="~R~F"/>
					<eval when="Else" output="~K~F"/>
				</flag>
			</flagSet>
			<flagSet name="_30FPS">
				<flag
					name="StreamFPS"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?FPS=(?&lt;fps&gt;[^;]+)"
					types="on=bool;fps=float"
				>
					<eval when="on &amp;&amp; fps &lt;= 0.0" output="#R#~k~FPS==0.0"/>
					<eval when="on &amp;&amp; fps &gt;= 30.0" output="~G~#g#FPS&gt;=30."/>
					<eval when="on &amp;&amp; fps &gt; 27.5" output="~G~FPS&gt;27.5"/>
					<eval when="on &amp;&amp; fps &gt; 25.0" output="~g~FPS&gt;25.0"/>
					<eval when="on &amp;&amp; fps &gt; 22.5" output="~Y~FPS&gt;22.5"/>
					<eval when="on &amp;&amp; fps &gt; 20.0" output="~y~FPS&gt;20.0"/>
					<eval when="on &amp;&amp; fps &gt; 15.0" output="~M~FPS&gt;15.0"/>
					<eval when="on &amp;&amp; fps &lt;= 15.0" output="~R~FPS&lt;=15!"/>
					<eval when="Else" output="~K~--fps---"/>
				</flag>
			</flagSet>
			<flagSet name="HighBitRate">
				<flag
					name="StreamBitRate"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?bitRate=(?&lt;kbps&gt;[^K]+)Kb/s .(?&lt;bps&gt;[^b]+)"
					types="on=bool;kbps=int;bps=int"
				>
					<eval when="on &amp;&amp; kbps &lt;= 0" output="~k~#R#B"/>
					<eval when="on &amp;&amp; kbps &gt;= 5000" output="~G~#g#B"/>
					<eval when="on &amp;&amp; kbps &gt; 4500" output="~G~B"/>
					<eval when="on &amp;&amp; kbps &gt; 3000" output="~g~B"/>
					<eval when="on &amp;&amp; kbps &gt; 2000" output="~Y~B"/>
					<eval when="on &amp;&amp; kbps &gt; 1000" output="~M~B"/>
					<eval when="on &amp;&amp; kbps &gt; 500" output="~R~B"/>
					<eval when="Else" output="~K~B"/>
				</flag>
			</flagSet>
			<flagSet name="_HighBitRate">
				<flag
					name="StreamBitRate"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?bitRate=(?&lt;kbps&gt;[^K]+)Kb/s .(?&lt;bps&gt;[^b]+)"
					types="on=bool;kbps=int;bps=int"
				>
					<eval when="on &amp;&amp; kbps &lt;= 0" output="~k~#R#=0!!!"/>
					<eval when="on &amp;&amp; kbps &gt;= 5000" output="~G~#g#&gt;=5k."/>
					<eval when="on &amp;&amp; kbps &gt; 4750" output="~G~&gt;4750"/>
					<eval when="on &amp;&amp; kbps &gt; 4500" output="~g~&gt;4500"/>
					<eval when="on &amp;&amp; kbps &gt; 4250" output="~Y~&gt;4250"/>
					<eval when="on &amp;&amp; kbps &gt; 4000" output="~y~&gt;4000"/>
					<eval when="on &amp;&amp; kbps &gt; 3750" output="~m~&gt;3750"/>
					<eval when="on &amp;&amp; kbps &gt; 3500" output="~M~&gt;3500"/>
					<eval when="on &amp;&amp; kbps &gt; 3250" output="~r~&gt;3250"/>
					<eval when="on &amp;&amp; kbps &gt; 3000" output="~R~&gt;3000"/>
					<eval when="Else" output="~K~bRate"/>
				</flag>
			</flagSet>
			<flagSet name="LowBitRate">
				<flag
					name="StreamBitRate"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?bitRate=(?&lt;kbps&gt;[^K]+)Kb/s .(?&lt;bps&gt;[^b]+)"
					types="on=bool;kbps=int;bps=int"
				>
					<eval when="on &amp;&amp; kbps &lt;= 0" output="~k~#R#B"/>
					<eval when="on &amp;&amp; kbps &gt;= 3000" output="~G~#g#B"/>
					<eval when="on &amp;&amp; kbps &gt; 2500" output="~G~B"/>
					<eval when="on &amp;&amp; kbps &gt; 2000" output="~g~B"/>
					<eval when="on &amp;&amp; kbps &gt; 1500" output="~Y~B"/>
					<eval when="on &amp;&amp; kbps &gt; 1000" output="~M~B"/>
					<eval when="on &amp;&amp; kbps &gt; 500" output="~R~B"/>
					<eval when="Else" output="~K~B"/>
				</flag>
			</flagSet>
			<flagSet name="_LowBitRate">
				<flag
					name="StreamBitRate"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?bitRate=(?&lt;kbps&gt;[^K]+)Kb/s .(?&lt;bps&gt;[^b]+)"
					types="on=bool;kbps=int;bps=int"
				>
					<eval when="on &amp;&amp; kbps &lt;= 0" output="~k~#R#=0!!!"/>
					<eval when="on &amp;&amp; kbps &gt;= 3000" output="~G~#g#&gt;=3k."/>
					<eval when="on &amp;&amp; kbps &gt; 2750" output="~G~&gt;2750"/>
					<eval when="on &amp;&amp; kbps &gt; 2500" output="~g~&gt;2500"/>
					<eval when="on &amp;&amp; kbps &gt; 2250" output="~Y~&gt;2250"/>
					<eval when="on &amp;&amp; kbps &gt; 2000" output="~y~&gt;2000"/>
					<eval when="on &amp;&amp; kbps &gt; 1750" output="~m~&gt;1750"/>
					<eval when="on &amp;&amp; kbps &gt; 1500" output="~M~&gt;1500"/>
					<eval when="on &amp;&amp; kbps &gt; 1250" output="~r~&gt;1250"/>
					<eval when="on &amp;&amp; kbps &gt; 1000" output="~R~&gt;1000"/>
					<eval when="Else" output="~K~bRate"/>
				</flag>
			</flagSet>
			<flagSet name="StreamHealth">
				<flag
					name="ReportedStrain"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+strain=(?&lt;strain&gt;[^%]+)"
					types="on=bool;strain=float"
				>
					<eval when="on &amp;&amp; strain &gt;= 1.0F" output="~k~#R#%"/>
					<eval when="on &amp;&amp; strain &lt;= 0.0F" output="~G~#g#0"/>
					<eval when="on &amp;&amp; strain &lt; 0.1F" output="~G~0"/>
					<eval when="on &amp;&amp; strain &lt; 0.2F" output="~g~1"/>
					<eval when="on &amp;&amp; strain &lt; 0.3F" output="~c~2"/>
					<eval when="on &amp;&amp; strain &lt; 0.4F" output="~C~3"/>
					<eval when="on &amp;&amp; strain &lt; 0.5F" output="~y~4"/>
					<eval when="on &amp;&amp; strain &lt; 0.6F" output="~Y~5"/>
					<eval when="on &amp;&amp; strain &lt; 0.7F" output="~m~6"/>
					<eval when="on &amp;&amp; strain &lt; 0.8F" output="~M~7"/>
					<eval when="on &amp;&amp; strain &lt; 0.9F" output="~r~8"/>
					<eval when="on &amp;&amp; strain &lt; 1.0F" output="~R~9"/>
					<eval when="Else" output="~K~?"/>
				</flag>
				<flag
					name="LocalStrain"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?time=(?&lt;time&gt;\d+); frames=(?&lt;frames&gt;[^;]+); dropped=(?&lt;dropped&gt;[^;]+)"
					types="on=bool;time=int;frames=int;dropped=int"
				>
					<defines>
						<define name="FPS" type="int">
							<value name="60" value="60"/>
							<value name="30" value="30"/>
						</define>
					</defines>

					<consts>
						<const name="HIST_LENGTH" type="int" value="10"/>
						<const name="SECS_PER_PING" type="int" value="2"/>
					</consts>

					<fields>
						<field name="i" type="int" value="0"/>
						<field name="localStrain" type="float" value="0"/>
						<field name="droppedFrames" type="int[]" value="new int[HIST_LENGTH]"/>
					</fields>

					<methods>
						<method
							name="UpdateHistory"
							code="
								droppedFrames[i] = FPS * time - frames;
								localStrain = (droppedFrames[i] - droppedFrames[(i + 1) % HIST_LENGTH] + dropped) / (float)(HIST_LENGTH * FPS * SECS_PER_PING);
								i = (i + 1) % HIST_LENGTH;
							"
						/>
						<method name="Reset" code="Array.Clear(droppedFrames, 0, droppedFrames.Length);"/>
					</methods>

					<eval when="on &amp;&amp; localStrain &gt;= 1.0F" output="~k~#R#%"/>
					<eval when="on &amp;&amp; localStrain &lt;= 0.0F" output="~G~#g#0"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.1F" output="~G~0"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.2F" output="~g~1"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.3F" output="~c~2"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.4F" output="~C~3"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.5F" output="~y~4"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.6F" output="~Y~5"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.7F" output="~m~6"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.8F" output="~M~7"/>
					<eval when="on &amp;&amp; localStrain &lt; 0.9F" output="~r~8"/>
					<eval when="on &amp;&amp; localStrain &lt; 1.0F" output="~R~9"/>
					<eval when="Else" output="~K~/"/>
				</flag>
				<flag
					name="HealthScore"
					transitionToOnMatch="CalcHealth:: score"
					onMatch="CalcHealth:: score.+ = (?&lt;score&gt;-?\d)"
					types="score=float"
				>
					<eval when="score &lt;= -7" output="~k~#R#0"/>
					<eval when="score &gt;= 7" output="~G~#g#D"/>
					<eval when="score == 6" output="~G~D"/>
					<eval when="score == 5" output="~g~C"/>
					<eval when="score == 4" output="~C~B"/>
					<eval when="score == 3" output="~c~A"/>
					<eval when="score == 2" output="~B~#y#9"/>
					<eval when="score == 1" output="~b~#y#8"/>
					<eval when="score == 0" output="~w~7"/>
					<eval when="score == -1" output="~k~#w#6"/>
					<eval when="score == -2" output="~k~#y#5"/>
					<eval when="score == -3" output="~k~#Y#4"/>
					<eval when="score == -4" output="~k~#m#3"/>
					<eval when="score == -5" output="~k~#M#2"/>
					<eval when="score == -6" output="~k~#r#1"/>
					<eval when="Else" output="~K~\"/>
				</flag>
				<flag
					name="CalculatedHealth"
					transitionToOnMatch="StreamingStatusPing|OnStreamingChanged.Stopped"
					onMatch="StreamingStatusPing..stream=(?&lt;on&gt;True|False);.+?FPS=(?&lt;fps&gt;[^;]+)[^(]+.(?&lt;bps&gt;[^b]+)b/s.; time=(?&lt;time&gt;\d+); frames=(?&lt;frames&gt;[^;]+); dropped=(?&lt;dropped&gt;[^;]+); strain=(?&lt;strain&gt;[^%]+)"
					types="on=bool;fps=float;bps=int;time=int;frames=int;dropped=int;strain=float"
				>
					<defines>
						<define name="FPS" type="int">
							<value name="60" value="60"/>
							<value name="30" value="30"/>
						</define>
						<define name="BITRATE" type="int">
							<value name="1080" value="4500"/>
							<value name="720" value="2500"/>
						</define>
					</defines>

					<consts>
						<const name="FPS_TARGET" type="int" value="FPS - 1"/>
						<const name="FPS_WARN" type="int" value="FPS * 3 / 4"/>
						<const name="FPS_BAD" type="int" value="FPS / 2"/>
						<const name="BYTE_RATE_TARGET" type="int" value="BITRATE * 128"/>
						<const name="BYTE_RATE_WARN" type="int" value="BITRATE * 128 * 2 / 3"/>

						<const name="offset1" type="float" value="-2.0F"/>
						<const name="scale" type="float" value="1.5F"/>
						<const name="offset2" type="float" value="1.8F"/>
						<const name="skew" type="float" value="0.1F"/>

						<const name="HIST_LENGTH" type="int" value="10"/>
						<const name="SECS_PER_PING" type="int" value="2"/>

						<!-- Measured as the fraction of FPS lost, averaged over the last HIST_LENGTH seconds: -->
						<const name="LOCAL_STRAIN_TARGET" type="float" value="0F"/>
						<const name="LOCAL_STRAIN_WARN" type="float" value="0.2F"/>
						<const name="LOCAL_STRAIN_BAD" type="float" value="0.5F"/>
					</consts>

					<fields>
						<field name="i" type="int" value="0"/>
						<field name="histSat" type="int" value="0"/>
						<field name="history" type="int[]" value="new int[HIST_LENGTH]"/>
						<field name="droppedFrames" type="int[]" value="new int[HIST_LENGTH]"/>
					</fields>

					<properties>
						<property
							name="Health"
							type="int"
							code="
								if (histSat == 0) {
									return 0;
								}


								var hist = history
									.Take(histSat)
									.Where(h => h &gt; 0);

								return hist.Any()
									? (int)Math.Round(
										hist.Select(health =&gt; (health + offset1) * scale + offset2)
											.Average()
											+ skew
									)
									: 0;
							"
						/>
					</properties>

					<methods>
						<method
							name="UpdateHistory"
							code="
								droppedFrames[i] = FPS * time - frames;
								var localStrain = (droppedFrames[i] - droppedFrames[(i + 1) % HIST_LENGTH] + dropped) / (float)(HIST_LENGTH * FPS * SECS_PER_PING);
								//Console.WriteLine(&quot;({0} - {1} + {2}) / ({3} * {4} * {5}) = {6} / {7} = {8}&quot;, droppedFrames[i], droppedFrames[(i + 1) % HIST_LENGTH], dropped, HIST_LENGTH, FPS, SECS_PER_PING, droppedFrames[i] - droppedFrames[(i + 1) % HIST_LENGTH] + dropped, HIST_LENGTH * FPS * SECS_PER_PING, localStrain);

								history[i] = (fps &gt;= FPS_TARGET &amp;&amp; bps &gt;= BYTE_RATE_TARGET &amp;&amp; localStrain == LOCAL_STRAIN_TARGET)
									? 4
									: (
										(fps &gt;= FPS_TARGET || bps &gt;= BYTE_RATE_TARGET || localStrain == LOCAL_STRAIN_TARGET)
										&amp;&amp; fps &gt;= FPS_WARN &amp;&amp; bps &gt;= BYTE_RATE_WARN &amp;&amp; localStrain &lt;= LOCAL_STRAIN_WARN
									)
										? 3
										: (
											(fps &gt;= FPS_WARN || bps &gt;= BYTE_RATE_WARN || localStrain &lt;= LOCAL_STRAIN_WARN)
											&amp;&amp; fps &gt;= FPS_BAD &amp;&amp; localStrain &lt;= LOCAL_STRAIN_BAD
										)
											? 2
											: 1;

								i = (i + 1) % HIST_LENGTH;
								histSat = Math.Min(histSat + 1, HIST_LENGTH);
							"
						/>
						<method
							name="Reset"
							code="
								Array.Clear(history, 0, history.Length);
								Array.Clear(droppedFrames, 0, droppedFrames.Length);
								histSat = 0;
							"
						/>
					</methods>

					<eval when="on &amp;&amp; Health == 1"		output="#R#~r~ Bad "/>
					<eval when="on &amp;&amp; Health == 2"		output="#M#~Y~ Avg "/>
					<eval when="on &amp;&amp; Health == 3"		output="#Y#~g~Good "/>
					<eval when="on &amp;&amp; Health &gt;= 4"	output="#G#~g~Great"/>
					<eval when="Else"							output="#K#~k~ None"/>
				</flag>
			</flagSet>
			<flagSet name="Conversation" trackID="Conversation(?:Start|End)ing(?:Begin|End)\(\) (?:enter|leave) \((?&lt;id&gt;[^)]+)?\)">
				<flag
					name="StartingBegin"
					off="~c~b"
					on="~C~b"
					onMatch="ConversationStartingBegin\(\) enter"
					offMatch="ConversationStartingBegin\(\) leave"
				/>
				<flag
					name="StartingEnd"
					off="~c~e"
					on="~C~e"
					onMatch="ConversationStartingEnd\(\) enter"
					offMatch="ConversationStartingEnd\(\) leave"
				/>
				<flag
					name="InConversation"
					off="~B~C"
					offMatch="ConversationEndingEnd\(\) leave"
					transitionToOff="#B#~Y~C"
					transitionToOffMatch="ConversationEndingBegin\(\) enter"
					transitionToOn="#y#~B~C"
					transitionToOnMatch="ConversationStartingBegin\(\) enter"
					on="~Y~C"
					onMatch="ConversationStartingEnd\(\) leave"
				/>
				<flag
					name="EndingBegin"
					off="~m~b"
					on="~M~b"
					onMatch="ConversationEndingBegin\(\) enter"
					offMatch="ConversationEndingBegin\(\) leave"
				/>
				<flag
					name="EndingEnd"
					off="~m~e"
					on="~M~e"
					onMatch="ConversationEndingEnd\(\) enter"
					offMatch="ConversationEndingEnd\(\) leave"
				/>
			</flagSet>
			<flagSet name="Recording">
				<flag name="CanRecord" off="~r~r" on="~g~r" offMatch="CanStartRecording conclusion:.+?canRec:False" onMatch="CanStartRecording conclusion:.+?canRec:True"/>
				<flag name="WantRecording" off="~r~R" on="~G~R" offMatch="\bStopping Recording\b|ConversationEndingBegin" onMatch="\bStarting Recording\b"/>
				<flag name="IsRecording" off="#K#~R~r" on="#K#~G~r" offMatch="CanStartRecording conclusion:.+?isRec:False" onMatch="CanStartRecording conclusion:.+?isRec:True"/>
				<flag name="ActiveRecording" off="#K#A" on="#K#~Y~A" offMatch="CanStartRecording conclusion:.+?hasActiveRec:False" onMatch="CanStartRecording conclusion:.+?hasActiveRec:True"/>
				<flag name="CanRecordButton" off="R" on="~G~R" offMatch="CanStartRecording conclusion: False" onMatch="CanStartRecording conclusion: True" initialState="On"/>
				<flag name="CanStopButton" off="S" on="~G~S" offMatch="CanStopRecording conclusion: False" onMatch="CanStopRecording conclusion: True"/>
			</flagSet>
			<flagSet name="MeetingTimer">
				<flag
					name="ActiveBooked"
					on="~g~B"
					off="~K~B"
					transitionToOn="~R~B"
					onMatch="ConsoleManager.+?active=\{.+hasAC=True\r?$"
					transitionToOnMatch="ConsoleManager.+?active=,.+hasAC=True\r?$"
					offMatch="ConsoleManager.+hasAC=False\r?$|ConversationEndingBegin"
				/>
				<flag
					name="ActiveMatch"
					transitionToOnMatch="ConsoleManager|ConversationEndingBegin"
					onMatch="(?x)
						(?&gt;								# Atomic group:
							.+?									# OneOrMore(ungreedy): Anything except newlines.
							ConsoleManager						# 'ConsoleManager'
							\ +									# OneOrMore(greedy): spaces.
							.									# Anything except newline.
						)
						\ active=							# ' active='
						\{									# '{'
						.+?									# OneOrMore(ungreedy): Anything except newlines.
						BookingId\.Hash=					# 'BookingId.Hash='
						(?&lt;activeID&gt;-?\d+)			# Named group 'activeID' is an int.
						[^}]+								# OneOrMore(greedy): Not '}'
						\}?									# Optional(greedy): '}'
						,\ currentScheduled=				# ', currentScheduled='
						(?:									# Optional(greedy):
							\{									# '{'
							.+?									# OneOrMore(ungreedy): Anything except newlines.
							BookingId\.Hash=					# 'BookingId.Hash='
							(?&lt;currentID&gt;-?\d+)			# Named group 'currentID' is an int.
							[^}]+								# OneOrMore(greedy): Not '}'
							\}?									# Optional(greedy): '}'
						)?
						,\ nextScheduled=					# ', nextScheduled='
						(?:
							\{									# '{'
							.+?									# OneOrMore(ungreedy): Anything except newlines.
							BookingId\.Hash=					# 'BookingId.Hash='
							(?&lt;nextID&gt;-?\d+)				# Named group 'nextID' is an int.
						)?
					"
					types="activeID=int;currentID=int?;nextID=int?"
				>
					<eval when="activeID == currentID" output="~G~="/>
					<eval when="activeID == nextID" output="~M~="/>
					<eval when="Else" output="~K~!"/>
				</flag>
				<flag
					name="ActiveBooking"
					off="~K~A"
					on="~Y~A"
					transitionToOn="~y~#y#a"
					offMatch="ConsoleManager +. active=,|ConversationEndingBegin"
					onMatch="ConsoleManager +. active=\{.+?IsAdhoc=False"
					transitionToOnMatch="ConsoleManager +. active=\{.+?IsAdhoc=True"
				/>
				<flag
					name="ActiveTime"
					transitionToOnMatch="ConsoleManager|ConversationEndingBegin"
					onMatch="(?x)
						^															# StartOfLine
						(?&lt;now&gt;\d{4}(?:-\d\d){2}\ (?:\d\d:){2}\d\d.\d{4})		# Named group 'now' is the DateTime at the start of the logLine.
						(?&gt;														# Atomic group:
							.+?															# OneOrMore(ungreedy): Anything except newlines.
							ConsoleManager												# 'ConsoleManager'
							\ +															# OneOrMore(greedy): spaces.
							.															# Anything except newline.
						)
						\ active=													# ' active='
						\{															# '{'
						.+?															# OneOrMore(ungreedy): Anything except newlines.
						Start=														# 'Start='
						(?&lt;start&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'start' is a DateTime.
						,\ End=														# ', End='
						(?&lt;end&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'end' is a DateTime.
					"
					types="now=DateTime;start=DateTime;end=DateTime"
				>
					<eval when="start - now &gt; TimeSpan.FromMinutes(10)" output="~y~»"/>
					<eval when="now &gt; end" output="~Y~&lt;"/>
					<eval when="now &gt;= start &amp;&amp; now &lt;= end" output="~Y~="/>
					<eval when="now &lt; start" output="~Y~&gt;"/>
					<eval when="Else" output="~K~."/>
				</flag>
				<flag
					name="CurrentBooking"
					off="~K~C"
					on="~G~C"
					transitionToOn="~G~#y#c"
					offMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=,|ConversationEndingBegin"
					onMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=\{.+?IsAdhoc=False"
					transitionToOnMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=\{.+?IsAdhoc=True"
				/>
				<flag
					name="CurrentTime"
					transitionToOnMatch="ConsoleManager|ConversationEndingBegin"
					onMatch="(?x)
						^															# StartOfLine
						(?&lt;now&gt;\d{4}(?:-\d\d){2}\ (?:\d\d:){2}\d\d.\d{4})		# Named group 'now' is the DateTime at the start of the logLine.
						(?&gt;														# Atomic group:
							.+?															# OneOrMore(ungreedy): Anything except newlines.
							ConsoleManager												# 'ConsoleManager'
							\ +															# OneOrMore(greedy): spaces.
							.															# Anything except newline.
						)
						\ active=													# ' active='
						(?:\{.+?)?													# Optional(greedy): '{'; then OneOrMore(ungreedy): Anything except newlines.
						(?&gt;,\ currentScheduled=)									# Atomic group: ' currentScheduled='
						\{															# '{'
						.+?															# OneOrMore(ungreedy): Anything except newlines.
						Start=														# 'Start='
						(?&lt;start&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'start' is a DateTime.
						,\ End=														# ', End='
						(?&lt;end&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'end' is a DateTime.
					"
					types="now=DateTime;start=DateTime;end=DateTime"
				>
					<eval when="start - now &gt; TimeSpan.FromMinutes(10)" output="~g~»"/>
					<eval when="now &gt; end" output="~G~&lt;"/>
					<eval when="now &gt;= start &amp;&amp; now &lt;= end" output="~G~="/>
					<eval when="now &lt; start" output="~G~&gt;"/>
					<eval when="Else" output="~K~."/>
				</flag>
				<flag
					name="NextBooking"
					off="~K~N"
					on="~M~N"
					transitionToOn="~m~#y#n"
					offMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=(\{.+?)?, nextScheduled=[^{]|ConversationEndingBegin"
					onMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=(\{.+?)?, nextScheduled=\{.+?IsAdhoc=False"
					transitionToOnMatch="ConsoleManager +. active=(\{.+?)?, currentScheduled=(\{.+?)?, nextScheduled=\{.+?IsAdhoc=True"
				/>
				<flag
					name="NextTime"
					transitionToOnMatch="ConsoleManager|ConversationEndingBegin"
					onMatch="(?x)
						^															# StartOfLine
						(?&lt;now&gt;\d{4}(?:-\d\d){2}\ (?:\d\d:){2}\d\d.\d{4})		# Named group 'now' is the DateTime at the start of the logLine.
						(?&gt;														# Atomic group:
							.+?															# OneOrMore(ungreedy): Anything except newlines.
							ConsoleManager												# 'ConsoleManager'
							\ +															# OneOrMore(greedy): spaces.
							.															# Anything except newline.
						)
						\ active=													# ' active='
						(?:\{.+?)?													# Optional(greedy): '{'; then OneOrMore(ungreedy): Anything except newlines.
						(?&gt;,\ currentScheduled=)									# Atomic group: ' currentScheduled='
						(?:\{.+?)?													# Optional(greedy): '{'; then OneOrMore(ungreedy): Anything except newlines.
						(?&gt;,\ nextScheduled=)									# Atomic group: ' nextScheduled='
						\{															# '{'
						.+?															# OneOrMore(ungreedy): Anything except newlines.
						Start=														# 'Start='
						(?&lt;start&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'start' is a DateTime.
						,\ End=														# ', End='
						(?&lt;end&gt;(?:\d\d/){2}\d{4}\ (?:\d\d?:){2}\d\d\ [AP]M)	# Named group 'end' is a DateTime.
					"
					types="now=DateTime;start=DateTime;end=DateTime"
				>
					<eval when="start - now &gt; TimeSpan.FromMinutes(10)" output="~m~»"/>
					<eval when="now &gt; end" output="~M~&lt;"/>
					<eval when="now &gt;= start &amp;&amp; now &lt;= end" output="~M~="/>
					<eval when="now &lt; start" output="~M~&gt;"/>
					<eval when="Else" output="~K~."/>
				</flag>
			</flagSet>
			<flagSet name="SeriLogRequest">
				<flag name="Request" on="~G~R" off="~K~R" onMatch="HostingRequestStartingLog" offMatch="HostingRequestFinishedLog"/>
			</flagSet>
		</flagSets>

		<ruleSets>
			<ruleSet name="SeriLog" reset="Application is shutting down">
				<vars>
					<var name="DateDash" value=""/>
					<var name="DateYear" value="~BLUE~#BLACK#"/>
					<var name="DateMonth" value=""/>
					<var name="DateDay" value=""/>
					<var name="DateSuffixSpace" value=""/>
					<var name="TimeColon" value=""/>
					<var name="TimeHours" value="~CYAN~"/>
					<var name="TimeMins" value=""/>
					<var name="TimeSecs" value="#yellow#"/>
					<var name="TimeDot" value="#BLACK#"/>
					<var name="TimeSecs/10" value="~WHITE~"/>
					<var name="TimeSecs/100" value="#black#"/>
					<var name="TimeSecs/1000" value="~white~"/>
					<var name="TimeSecs/10000" value="~BLACK~"/>
					<var name="TimeSecs/100000" value="~yellow~"/>
					<var name="TimeSecs/1000000" value="~green~"/>
					<var name="TimeSecs/10000000" value="~blue~"/>

					<var name="Trace" value="~BLACK~#b#"/>
					<var name="Debug" value="~white~#B#"/>
					<var name="Info" value="~WHITE~#K#"/>
					<var name="Warn" value="~YELLOW~#y#"/>
					<var name="Error" value="~RED~#y#"/>
					<var name="Fatal" value="~WHITE~#RED#"/>

					<var name="ExceptionNamespace" value="~magenta~#black#"/>
					<var name="ExceptionClass" value="~CYAN~#magenta#"/>
					<!-- And the space after it: -->
					<var name="ExceptionColon" value="~white~#yellow#"/>
					<var name="ExceptionMessage" value="~YELLOW~#red#"/>
					<!-- Includes the spaces either side: -->
					<var name="InnerExceptionArrow" value="#black# ~RED~-#BLACK#-#white#-#WHITE#&gt;#black# "/>

					<!-- Includes the spaces either side, as well as the EndOfInnerException marker line: -->
					<var name="StackTraceAt" value="~MAGENTA~#magenta#"/>
					<var name="StackTraceNamespace" value="~BLACK~"/>
					<var name="StackTraceNamespaceDot" value="~white~"/>
					<var name="StackTraceClass" value="~GREEN~"/>
					<var name="StackTraceMember" value="~YELLOW~"/>
					<var name="StackTraceArgsPunctuation" value="~BLUE~"/>
					<var name="StackTraceArgsTypes" value="~cyan~"/>
					<var name="StackTraceArgsNames" value="~yellow~"/>
					<var name="StackTraceDetailsIn" value="~BLACK~"/>
					<var name="StackTraceDetailsPath" value="~green~"/>
					<var name="StackTraceDetailsPathSlash" value="~BLACK~"/>
					<var name="StackTraceDetailsDir" value="~GREEN~"/>
					<var name="StackTraceDetailsFilename" value="~YELLOW~"/>
					<var name="StackTraceDetailsColon" value="~BLACK~"/>
					<var name="StackTraceDetailsLine" value=""/>
					<var name="StackTraceDetailsLineNumber" value="~CYAN~"/>

					<var name="JSON.indent" value="   "/>
					<var name="JSON.prop" value="~y~"/>
					<var name="JSON.:" value="~Y~"/>
					<var name="JSON.," value="~r~"/>
					<var name="JSON.{}" value="~m~"/>
					<var name="JSON.[]" value="~c~"/>
					<var name="JSON.&quot;" value="~g~"/>
					<var name="JSON.!" value="~B~"/>
					<var name="JSON.0" value="~B~"/>
					<var name="JSON.0.0" value="#b#~c~"/>
					<var name="JSON.null" value="#b#~R~"/>
					<var name="JSON.undefined" value="#r#~B~"/>
				</vars>

				<rule name="ContainerPrefix" match="^([A-Za-z\d_-]+)\s+\|\s+(\{.+)}$" replace="$2,&quot;__container&quot;:&quot;$1&quot;}"/>

				<rule name="Trace" test="&quot;@l&quot;:&quot;Trace|Verbose&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Trace% [TRACE] "/>
				<rule name="Debug" test="&quot;@l&quot;:&quot;Debug&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Debug% [DEBUG] "/>
				<!--<rule name="Info" test="&quot;@l&quot;:&quot;Info(?:rmation)?&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Info% [ INFO] "/>-->
				<rule name="Info" test="^(?!.*&quot;@l&quot;:&quot;).+" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Info% [ INFO] "/>
				<rule name="Warn" test="&quot;@l&quot;:&quot;Warn(?:ing)?&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Warn% [WARN ] "/>
				<rule name="Error" test="&quot;@l&quot;:&quot;Error&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Error% [ERROR] "/>
				<rule name="Fatal" test="&quot;@l&quot;:&quot;Fatal&quot;" match="(?&lt;=&quot;@mt&quot;:&quot;)" replace="%Fatal% [FATAL] "/>

				<rule
					name="json"
					match="^(?:~[^~]+~|#[^#]+#)*(?:\{&quot;)?(?&lt;JSON&gt;\{\S.+})(?:~[^~]+~|#[^#]+#)*$"
					parse="JSON"
					replace="~&lt;~~B~${JSON.read(@t)} ~&gt;~${JSON.read(@mt)}${JSON.read?(@x)}${JSON.unread()}"
				>
					<group
						name="@t"
						match="^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d).(\d)(\d)(\d)(\d)(\d)(\d)(\d)"
						replace="%DateYear%$1%DateDash%-%DateMonth%$2%DateDash%-%DateDay%$3%DateSuffixSpace% %TimeHours%$4%TimeColon%:%TimeMins%$5%TimeColon%:%TimeSecs%$6%TimeDot%.%TimeSecs/10%$7%TimeSecs/100%$8%TimeSecs/1000%$9%TimeSecs/10000%$10%TimeSecs/100000%$11%TimeSecs/1000000%$12%TimeSecs/10000000%$13"
					/>
					<group name="@mt" match="\{(?&lt;prop&gt;[^}]+)}" parse="Parent" replace="~&lt;~~Y~#&lt;##b#${prop}#&gt;#~G~:~Y~${JSON.read($prop)}~&gt;~"/>
					<group name="@x" match="(?s).+" replace="\n$0\n">
						<group
							name="0.Exception"
							test="Exception\b"
							match="(?x)									# IgnorePatternWhitespace
								(?&lt;namespace&gt;						# Named group 'namespace' is:
									(?:										# ZeroOrMore(greed0:
										(?&gt;									# Atomic group:
											[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
										)
										\.										# '.'
									)*
								)
								(?&lt;class&gt;							# Named group 'class' is:
									\w*										# ZeroOrMore(greedy): Any word character
									Exception								# 'Exception'
									\b										# Zero-width word-boundary assertion.
									[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
								)
								(?&lt;colon&gt;							# Named group 'colon' is:
										\.									# Either: '.'
									|										# Or:
										(?:										# Optional(greedy):
											\ \(0x									# ' (0x'
											[\dA-Fa-f]{8}							# Exactly 8 hex digits
											\)										# ')'
										)?
										:[ ]									# ': '
								)
								(?&lt;message&gt;						# Optional(greedy): Named group 'message' is:
									.+										# OneOrMore(greedy): anything except newlines
								)?
							"
							replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}%ExceptionMessage%${message}"
						>
							<!-- 2 modifications to the same group need unique IDs so we .suffix them: -->
							<group
								name="message.0"
								match="(?x)
									(?&lt;namespace&gt;						# Named group 'namespace' is:
										(?:										# ZeroOrMore(greed0:
											(?&gt;									# Atomic group:
												[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
											)
											\.										# '.'
										)*
									)
									(?&lt;class&gt;							# Named group 'class' is:
										\w*										# ZeroOrMore(greedy): Any word character
										Exception								# 'Exception'
										[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
									)
									(?&lt;colon&gt;							# Named group 'colon' is:
											\.									# Either: '.'
										|										# Or:
											(?:										# Optional(greedy):
												\ \(0x									# ' (0x'
												[\dA-Fa-f]{8}							# Exactly 8 hex digits
												\)										# ')'
											)?
											:[ ]									# ': '
									)
								"
								replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}"
							/>
							<group name="message.1" match=" ?---&gt; " replace="%InnerExceptionArrow%"/>
						</group>
						<group name="0.ExceptionHilight" match="Exception" replace="#M#$0"/>

						<group
							name="0.StackTrace"
							test="(?m)(?:^|Current Stack: )   (?:at |--- End of inner)"
							match="(?mx)							# MultiLine, IgnorePatternWhitespace
								(?:^|Current\ Stack:\ )				# StartOfLine or 'Current Stack: '
								(?&lt;at&gt;						# Named group 'at' is:
									\ {3}								# 3 spaces (note that in (?x) mode, significant WS must be escaped)
									(?:									# Either:
											at[ ]							# 'at ' (see above re WS)
										|								# Or:
											---								# '---'
											.+								# OneOrMore(greedy) anything except newlines (i.e. the rest of the line)
									)
								)
								(?:									# Optional(greedy):
									(?&lt;namespace&gt;					# Named group 'namespace' is:
										(?:									# ZeroOrMore(greedy):
											(?&gt;								# Atomic group: (no backtracking into this - all or nothing; used for failing match efficiency)
												[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
											)
											\.									# '.'
										)*
									)
									(?&lt;class&gt;						# Named group 'class' is:
										(?&gt;								# Atomic group:
											[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
										)
										\.									# '.'
									)
									(?&lt;member&gt;					# Named group 'member' is: # Either:
											\.ctor								# '.ctor'
										|									# Or:
											(?&gt;								# Atomic group:
												[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
											)
									)
									(?&lt;args&gt;						# Named group 'args' is:
										\(									# '('
										(?&gt;								# Atomic group:
											[^)]*								# ZeroOrMore(greedy): Not ')'
										)
										\)									# ')'
									)
									(?&lt;details&gt;					# Optional(greedy): Named group 'details' is:
										\ in[ ]								# ' in '
										.+									# OneOrMore(greedy): anything except newlines
										:line[ ]							# ':line '
										\d+									# OneOrMore(greedy): digits
									)?
								)?
							"
							replace="%StackTraceAt%${at}%StackTraceNamespace%${namespace}%StackTraceClass%${class}%StackTraceMember%${member}%StackTraceArgsPunctuation%${args}${details}"
						>
							<group name="namespace.0" match="^IPFX" replace="~W~$0"/>
							<group name="namespace.1" match="^System" replace="~B~$0"/>
							<group name="namespace.2" match="\." replace="%StackTraceNamespaceDot%."/>
							<group
								name="args"
								match="(?x)								# IgnorePatternWhitespace
									(?&lt;type&gt;						# Named group 'type' is:
										[^(]+?								# OneOrMore(ungreedy): Not '('
									)
									\s									# Whitespace
									(?&lt;name&gt;						# Named group 'name' is:
										[^\s,)]+							# OneOrMore(greedy): Not whitespace nor ',' nor ')'
									)
									(?=									# Followed by (zero-length positive lookahead)
											,								# Either: ','
										|									# Or:
											\)									# ')'
									)
								"
								replace="%StackTraceArgsTypes%${type} %StackTraceArgsNames%${name}"
							/>
							<group
								name="details"
								match="(?x)								# IgnorePatternWhitespace
									in[ ]								# 'in '
									(?&lt;path&gt;						# Named group 'path' is:
										.{4}								# Exactly 4: anything except newlines (to skip over drivename colon complications)
										[^:]+								# OneOrMore(greedy): Not ':'
										[/\\]								# '/' or '\'
									)
									(?&lt;file&gt;						# Named group 'file' is:
										[^/\\:]+							# OneOrMore(greedy): Not: '/' nor '\' nor ':'
									)
									:line[ ]							# ':line '
									(?&lt;line&gt;						# Named group 'line' is:
										\d+									# OneOrMore(greedy): digits
									)
								"
								replace="%StackTraceDetailsIn%in %StackTraceDetailsPath%${path}%StackTraceDetailsFilename%${file}%StackTraceDetailsColon%:%StackTraceDetailsLine%line %StackTraceDetailsLineNumber%${line}"
							>
								<group
									name="path"
									match="(?x)								# IgnorePatternWhitespace
										^									# StartOfLine (in this case, the start of the group's match)
										(?&lt;path&gt;						# Named group 'path' is:
											(?:									# OneOrMore(greedy):
												(?&gt;								# Atomic group:
													[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
												)
												[/\\]								# '/' or '\'
											)+
										)
										(?&lt;dir&gt;						# Named group 'dir' is:
											(?&gt;								# Atomic group:
												[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
											)
											[/\\]								# '/' or '\'
										)
										$									# EndOfLine (in this case, the end of the group's match)
									"
									replace="${path}%StackTraceDetailsDir%${dir}"
								>
									<group name="path" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
									<group name="dir" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
								</group>
							</group>
						</group>
					</group>
				</rule>
				<rule name="env" match="^((?:Hosting environment|Content root path): )(.+)" replace="$1#b#~C~$2"/>
				<rule name="listening" match="^(Now listening on: )(.+)" replace="~G~$1#g#~C~$2"/>
				<rule name="app" match="^Application .+" replace="~Y~$0"/>
				<rule name="text" match="(?s)^(?:~[^~]+~|#[^#]+#)*(?!\d{4}(?:-\d\d){2})[^{].+" replace="~W~$0"/>
			</ruleSet>

			<ruleSet name="VFXLog" recordStart="^\d{4}(?:-\d\d){2} (?:\d\d:){2}\d\d.\d{4}" reset="\[F\]\[App +\] Version:|RoomScheduleViewModel +. (?:Shutting Down|Restarting) Computer">
				<vars>
					<var name="DateDash" value=""/>
					<var name="DateYear" value="~BLUE~#BLACK#"/>
					<var name="DateMonth" value=""/>
					<var name="DateDay" value=""/>
					<var name="DateSuffixSpace" value=""/>
					<var name="TimeColon" value=""/>
					<var name="TimeHours" value="~CYAN~"/>
					<var name="TimeMins" value=""/>
					<var name="TimeSecs" value="#yellow#"/>
					<var name="TimeDot" value="#BLACK#"/>
					<var name="TimeSecs/10" value="~WHITE~"/>
					<var name="TimeSecs/100" value="#black#"/>
					<var name="TimeSecs/1000" value="~white~"/>
					<var name="TimeSecs/10000" value="~BLACK~"/>

					<var name="Trace" value="~BLACK~"/>
					<var name="Debug" value="~white~"/>
					<var name="Info" value="~WHITE~"/>
					<var name="Warn" value="~YELLOW~"/>
					<var name="Error" value="~RED~"/>
					<var name="Fatal" value="~WHITE~#RED#"/>

					<var name="ClassName" value="#blue#"/>
					<var name="ThreadID" value="#green#"/>

					<var name="ExceptionNamespace" value="~magenta~#black#"/>
					<var name="ExceptionClass" value="~CYAN~#magenta#"/>
					<!-- And the space after it: -->
					<var name="ExceptionColon" value="~white~#yellow#"/>
					<var name="ExceptionMessage" value="~YELLOW~#red#"/>
					<!-- Includes the spaces either side: -->
					<var name="InnerExceptionArrow" value="#black# ~RED~-#BLACK#-#white#-#WHITE#&gt;#black# "/>

					<!-- Includes the spaces either side, as well as the EndOfInnerException marker line: -->
					<var name="StackTraceAt" value="~MAGENTA~#magenta#"/>
					<var name="StackTraceNamespace" value="~BLACK~"/>
					<var name="StackTraceNamespaceDot" value="~white~"/>
					<var name="StackTraceClass" value="~GREEN~"/>
					<var name="StackTraceMember" value="~YELLOW~"/>
					<var name="StackTraceArgsPunctuation" value="~BLUE~"/>
					<var name="StackTraceArgsTypes" value="~cyan~"/>
					<var name="StackTraceArgsNames" value="~yellow~"/>
					<var name="StackTraceDetailsIn" value="~BLACK~"/>
					<var name="StackTraceDetailsPath" value="~green~"/>
					<var name="StackTraceDetailsPathSlash" value="~BLACK~"/>
					<var name="StackTraceDetailsDir" value="~GREEN~"/>
					<var name="StackTraceDetailsFilename" value="~YELLOW~"/>
					<var name="StackTraceDetailsColon" value="~BLACK~"/>
					<var name="StackTraceDetailsLine" value=""/>
					<var name="StackTraceDetailsLineNumber" value="~CYAN~"/>
				</vars>

				<!---->
				<rule
					name="DateTime"
					match="^(\d{4})-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d).(\d)(\d)(\d)(\d)"
					replace="%DateYear%$1%DateDash%-%DateMonth%$2%DateDash%-%DateDay%$3%DateSuffixSpace% %TimeHours%$4%TimeColon%:%TimeMins%$5%TimeColon%:%TimeSecs%$6%TimeDot%.%TimeSecs/10%$7%TimeSecs/100%$8%TimeSecs/1000%$9%TimeSecs/10000%$10"
				/>
				<!--
				<rule
					name="Time"
					match="^(\d{4})-(\d\d)-(\d\d) (\d\d):(\d\d):(\d\d).(\d)(\d)(\d)(\d)"
					replace="%DateYear%$4%DateDash%:%TimeMins%$5%TimeColon%:%TimeSecs%$6%TimeDot%.%TimeSecs/10%$7%TimeSecs/100%$8%TimeSecs/1000%$9%TimeSecs/10000%$10"
				/>
				-->
				<rule name="ThreadID" match="\[[ \d]+\](?= \[.\])" replace="%ThreadID%$0"/>
				<rule name="ClassName" match="(?&lt;=\[.\])\[[^]]+\]" replace="%ClassName%$0"/>

				<rule
					name="Exception"
					test="Exception\b"
					match="(?x)									# IgnorePatternWhitespace
						(?&lt;namespace&gt;						# Named group 'namespace' is:
							(?:										# ZeroOrMore(greed0:
								(?&gt;									# Atomic group:
									[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
								)
								\.										# '.'
							)*
						)
						(?&lt;class&gt;							# Named group 'class' is:
							\w*										# ZeroOrMore(greedy): Any word character
							Exception								# 'Exception'
							\b										# Zero-width word-boundary assertion.
							[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
						)
						(?&lt;colon&gt;							# Named group 'colon' is:
								\.									# Either: '.'
							|										# Or:
								(?:										# Optional(greedy):
									\ \(0x									# ' (0x'
									[\dA-Fa-f]{8}							# Exactly 8 hex digits
									\)										# ')'
								)?
								:[ ]									# ': '
						)
						(?&lt;message&gt;						# Optional(greedy): Named group 'message' is:
							.+										# OneOrMore(greedy): anything except newlines
						)?
					"
					replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}%ExceptionMessage%${message}"
				>
					<!-- 2 modifications to the same group need unique IDs so we .suffix them: -->
					<group
						name="message.0"
						match="(?x)
							(?&lt;namespace&gt;						# Named group 'namespace' is:
								(?:										# ZeroOrMore(greed0:
									(?&gt;									# Atomic group:
										[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
									)
									\.										# '.'
								)*
							)
							(?&lt;class&gt;							# Named group 'class' is:
								\w*										# ZeroOrMore(greedy): Any word character
								Exception								# 'Exception'
								[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
							)
							(?&lt;colon&gt;							# Named group 'colon' is:
									\.									# Either: '.'
								|										# Or:
									(?:										# Optional(greedy):
										\ \(0x									# ' (0x'
										[\dA-Fa-f]{8}							# Exactly 8 hex digits
										\)										# ')'
									)?
									:[ ]									# ': '
							)
						"
						replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}"
					/>
					<group name="message.1" match=" ---&gt; " replace="%InnerExceptionArrow%"/>
				</rule>
				<rule name="ExceptionHilight" match="Exception" replace="#M#$0"/>

				<rule
					name="StackTrace"
					test="(?m)(?:^|Current Stack: )   (?:at |--- End of inner)"
					match="(?mx)							# MultiLine, IgnorePatternWhitespace
						(?:^|Current\ Stack:\ )				# StartOfLine or 'Current Stack: '
						(?&lt;at&gt;						# Named group 'at' is:
							\ {3}								# 3 spaces (note that in (?x) mode, significant WS must be escaped)
							(?:									# Either:
									at[ ]							# 'at ' (see above re WS)
								|								# Or:
									---								# '---'
									.+								# OneOrMore(greedy) anything except newlines (i.e. the rest of the line)
							)
						)
						(?:									# Optional(greedy):
							(?&lt;namespace&gt;					# Named group 'namespace' is:
								(?:									# ZeroOrMore(greedy):
									(?&gt;								# Atomic group: (no backtracking into this - all or nothing; used for failing match efficiency)
										[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
									)
									\.									# '.'
								)*
							)
							(?&lt;class&gt;						# Named group 'class' is:
								(?&gt;								# Atomic group:
									[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
								)
								\.									# '.'
							)
							(?&lt;member&gt;					# Named group 'member' is: # Either:
									\.ctor								# '.ctor'
								|									# Or:
									(?&gt;								# Atomic group:
										[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
									)
							)
							(?&lt;args&gt;						# Named group 'args' is:
								\(									# '('
								(?&gt;								# Atomic group:
									[^)]*								# ZeroOrMore(greedy): Not ')'
								)
								\)									# ')'
							)
							(?&lt;details&gt;					# Optional(greedy): Named group 'details' is:
								\ in[ ]								# ' in '
								.+									# OneOrMore(greedy): anything except newlines
								:line[ ]							# ':line '
								\d+									# OneOrMore(greedy): digits
							)?
						)?
					"
					replace="%StackTraceAt%${at}%StackTraceNamespace%${namespace}%StackTraceClass%${class}%StackTraceMember%${member}%StackTraceArgsPunctuation%${args}${details}"
				>
					<group name="namespace.0" match="^IPFX" replace="~W~$0"/>
					<group name="namespace.1" match="^System" replace="~B~$0"/>
					<group name="namespace.2" match="\." replace="%StackTraceNamespaceDot%."/>
					<group
						name="args"
						match="(?x)								# IgnorePatternWhitespace
							(?&lt;type&gt;						# Named group 'type' is:
								[^(]+?								# OneOrMore(ungreedy): Not '('
							)
							\s									# Whitespace
							(?&lt;name&gt;						# Named group 'name' is:
								[^\s,)]+							# OneOrMore(greedy): Not whitespace nor ',' nor ')'
							)
							(?=									# Followed by (zero-length positive lookahead)
									,								# Either: ','
								|									# Or:
									\)									# ')'
							)
						"
						replace="%StackTraceArgsTypes%${type} %StackTraceArgsNames%${name}"
					/>
					<group
						name="details"
						match="(?x)								# IgnorePatternWhitespace
							in[ ]								# 'in '
							(?&lt;path&gt;						# Named group 'path' is:
								.{4}								# Exactly 4: anything except newlines (to skip over drivename colon complications)
								[^:]+								# OneOrMore(greedy): Not ':'
								[/\\]								# '/' or '\'
							)
							(?&lt;file&gt;						# Named group 'file' is:
								[^/\\:]+							# OneOrMore(greedy): Not: '/' nor '\' nor ':'
							)
							:line[ ]							# ':line '
							(?&lt;line&gt;						# Named group 'line' is:
								\d+									# OneOrMore(greedy): digits
							)
						"
						replace="%StackTraceDetailsIn%in %StackTraceDetailsPath%${path}%StackTraceDetailsFilename%${file}%StackTraceDetailsColon%:%StackTraceDetailsLine%line %StackTraceDetailsLineNumber%${line}"
					>
						<group
							name="path"
							match="(?x)								# IgnorePatternWhitespace
								^									# StartOfLine (in this case, the start of the group's match)
								(?&lt;path&gt;						# Named group 'path' is:
									(?:									# OneOrMore(greedy):
										(?&gt;								# Atomic group:
											[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
										)
										[/\\]								# '/' or '\'
									)+
								)
								(?&lt;dir&gt;						# Named group 'dir' is:
									(?&gt;								# Atomic group:
										[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
									)
									[/\\]								# '/' or '\'
								)
								$									# EndOfLine (in this case, the end of the group's match)
							"
							replace="${path}%StackTraceDetailsDir%${dir}"
						>
							<group name="path" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
							<group name="dir" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
						</group>
					</group>
				</rule>

				<rule name="Trace" test="\[T\]" match=".+" replace="%Trace%$0"/>
				<rule name="Debug" test="\[D\]" match=".+" replace="%Debug%$0"/>
				<rule name="Info" test="\[I\]" match=".+" replace="%Info%$0"/>
				<rule name="Warn" test="\[W\]" match=".+" replace="%Warn%$0"/>
				<rule name="Error" test="\[E\]" match=".+" replace="%Error%$0"/>
				<rule name="Fatal" test="\[F\]" match=".+" replace="%Fatal%$0"/>

				<rule
					name="MeetingTimer"
					test="ConsoleManager"
					match="(?x)
						active=
						(
							\{
							Booking
							(?:
									(?&gt;[^{},]+)
								|
									,[ ]
								|
									\{
									(?&gt;[^}]+)
									\}
							)+
							\}?
						)?
						,\ currentScheduled=
						(
							\{
							Booking
							(?:
									(?&gt;[^{},]+)
								|
									,[ ]
								|
									\{
									(?&gt;[^}]+)
									\}
							)+
							\}?
						)?
						,\ nextScheduled=
						(
							\{
							Booking
							(?:
									(?&gt;[^{},]+)
								|
									,[ ]
								|
									\{
									(?&gt;[^}]+)
									\}
							)+
							\}?
						)?
						(?:
							,[ ]
							(
								hasAC=
								.+
							)
						)?
					"
					replace="#Y#A=$1#!#, #C#C=$2#!#, #G#N=$3#!#, #r#$4"
				>
					<group
						name="1.1"
						match="^{Booking: Id=(\d+), ConferenceGuid=(?:{[0-9A-F-]+})?, IsAdhoc=(?:(F)alse|(T)rue), Start=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, End=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, Subject=([^,\n]+).+?(?:, BookingId\.Hash=(-?\d+).+)?\}?$"
						replace="{~&lt;~~B~$1~&gt;~/~&lt;~~R~$7~&gt;~, ~&lt;~~M~AH=$2~B~$3~&gt;~, ~&lt;~~g~$4~&gt;~-~&lt;~~r~$5~&gt;~; $6}"
					/>
					<group name="1.2" match=":00 " replace=" "/>
					<group
						name="2.1"
						match="^{Booking: Id=(\d+), ConferenceGuid=(?:{[0-9A-F-]+})?, IsAdhoc=(?:(F)alse|(T)rue), Start=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, End=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, Subject=([^,\n]+).+?(?:, BookingId\.Hash=(-?\d+).+)?\}?$"
						replace="{~&lt;~~B~$1~&gt;~/~&lt;~~R~$7~&gt;~, ~&lt;~~M~AH=$2~B~$3~&gt;~, ~&lt;~~g~$4~&gt;~-~&lt;~~r~$5~&gt;~; $6}"
					/>
					<group name="2.2" match=":00 " replace=" "/>
					<group
						name="3.1"
						match="^{Booking: Id=(\d+), ConferenceGuid=(?:{[0-9A-F-]+})?, IsAdhoc=(?:(F)alse|(T)rue), Start=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, End=(?:\d\d?/){2}\d{4} (\d\d?:\d\d:\d\d [AP])M, Subject=([^,\n]+).+?(?:, BookingId\.Hash=(-?\d+).+)?\}?$"
						replace="{~&lt;~~B~$1~&gt;~/~&lt;~~R~$7~&gt;~, ~&lt;~~M~AH=$2~B~$3~&gt;~, ~&lt;~~g~$4~&gt;~-~&lt;~~r~$5~&gt;~; $6}"
					/>
					<group name="3.2" match=":00 " replace=" "/>
					<group name="4" match="hasAC=(T)rue|(F)alse" replace="AC=~G~$1~M~$2"/>
				</rule>

				<rule name="ConversationLifecycle" match="(Conversation)(Starting|Ending)(Begin|End)\(\) (enter|leave) \((.+)?\)" replace="#b#$1$2$3() $4 ($5)">
					<group name="2.1" match="Starting" replace="~C~$0"/>
					<group name="2.2" match="Ending" replace="~M~$0"/>
					<group name="3.1" match="Begin" replace="~G~$0"/>
					<group name="3.2" match="End" replace="~R~$0"/>
					<group name="4.1" match="enter" replace="~g~$0"/>
					<group name="4.2" match="leave" replace="~r~$0"/>
					<group name="5" match=".+" replace="~Y~$0"/>
				</rule>

				<rule
					name="StreamingStatusPing"
					test="StreamingStatusPing"
					match="StreamingStatusPing..stream=(?&lt;prefix&gt;(?:True|False); rec=(?:True|False); FPS=\d+(?:\.\d\d?)?)[^;]+; bitRate=(?&lt;bps&gt;[^ ]+) [^;]+; time=(?&lt;time&gt;[^;]+); frames=(?&lt;frames&gt;[^;]+); dropped=(?&lt;drops&gt;[^;]+); strain=(?&lt;strain&gt;[^%]+)%.. ==> Health = (?&lt;health&gt;.+)"
					replace="~c~StreamingStatusPing~!~:live=${prefix} BPS=${bps}; T=${time}; Frames=${frames}~R~-${drops}~!~; ~C~Strain~!~=~Y~${strain}%~!~; ~W~Health~!~=${health}"
				>
					<group name="prefix.T" match="True" replace="~G~$0"/>
					<group name="prefix.F" match="False" replace="~M~$0"/>
					<group name="health.bad" match="Bad" replace="#R#$0"/>
					<group name="health.avg" match="Average" replace="~M~$0"/>
					<group name="health.good" match="Good" replace="~Y~$0"/>
					<group name="health.great" match="Great" replace="~G~$0"/>
				</rule>
			</ruleSet>

			<ruleSet name="LyncLog" recordStart="^(?:\d\d/){2}\d{4}\|(?:\d\d:){2}\d\d.\d{3} ">
				<vars>
					<var name="DateDash" value=""/>
					<var name="DateYear" value="~BLUE~#BLACK#"/>
					<var name="DateMonth" value=""/>
					<var name="DateDay" value=""/>
					<var name="DateSuffixSpace" value=""/>
					<var name="TimeColon" value=""/>
					<var name="TimeHours" value="~CYAN~"/>
					<var name="TimeMins" value=""/>
					<var name="TimeSecs" value="#yellow#"/>
					<var name="TimeDot" value="#BLACK#"/>
					<var name="TimeSecs/10" value="~WHITE~"/>
					<var name="TimeSecs/100" value="#black#"/>
					<var name="TimeSecs/1000" value="~white~"/>
					<var name="TimeSecs/10000" value="~BLACK~"/>

					<var name="Trace" value="~BLACK~"/>
					<var name="Debug" value="~white~"/>
					<var name="Info" value="~WHITE~"/>
					<var name="Warn" value="~YELLOW~"/>
					<var name="Error" value="~RED~"/>
					<var name="Fatal" value="~WHITE~#RED#"/>

					<var name="ClassName" value="#blue#"/>
				</vars>

				<rule
					name="DateTime"
					match="^(\d\d)/(\d\d)/(\d{4})\|(\d\d):(\d\d):(\d\d).(\d)(\d)(\d)"
					replace="%DateYear%$3%DateDash%-%DateMonth%$1%DateDash%-%DateYear%$2%DateSuffixSpace% %TimeHours%$4%TimeColon%:%TimeMins%$5%TimeColon%:%TimeSecs%$6%TimeDot%.%TimeSecs/10%$7%TimeSecs/100%$8%TimeSecs/1000%$9"
				/>
				<rule name="ClassName" match=" :: (?:\w+::)?" replace="%ClassName%$0"/>

				<rule name="Trace" test="\bTRACE\b" match=".+" replace="%Trace%$0"/>
				<rule name="Debug" test="\bDEBUG\b" match=".+" replace="%Debug%$0"/>
				<rule name="Info" test="\bINFO\b" match=".+" replace="%Info%$0"/>
				<rule name="Warn" test="\bWARN\b" match=".+" replace="%Warn%$0"/>
				<rule name="Error" test="\bERROR\b" match=".+" replace="%Error%$0"/>
				<rule name="Fatal" test="\bFATAL\b" match=".+" replace="%Fatal%$0"/>
			</ruleSet>

			<ruleSet name="OBSLog" recordStart="^(?:\d\d:){2}\d\d.\d{3}:">
				<vars>
					<var name="DateDash" value=""/>
					<var name="TimeColon" value="~BLACK~"/>
					<var name="TimeHours" value="~CYAN~"/>
					<var name="TimeMins" value="~CYAN~"/>
					<var name="TimeSecs" value="#yellow#~CYAN~"/>
					<var name="TimeDot" value="#BLACK#"/>
					<var name="TimeSecs/10" value="~WHITE~"/>
					<var name="TimeSecs/100" value="#black#"/>
					<var name="TimeSecs/1000" value="~white~"/>

					<var name="Trace" value="~BLACK~"/>
					<var name="Debug" value="~white~"/>
					<var name="Info" value="~WHITE~"/>
					<var name="Warn" value="~YELLOW~"/>
					<var name="Error" value="~RED~"/>
					<var name="Fatal" value="~WHITE~#RED#"/>

					<var name="ClassName" value="#blue#"/>
				</vars>

				<rule
					name="DateTime"
					match="^(\d\d):(\d\d):(\d\d).(\d)(\d)(\d):"
					replace="%TimeHours%$1%TimeColon%:%TimeMins%$2%TimeColon%:%TimeSecs%$3%TimeDot%.%TimeSecs/10%$4%TimeSecs/100%$5%TimeSecs/1000%$6%TimeColon%:"
				/>
				<rule name="ClassName" match="\[[^]]+\]" replace="%ClassName%$0"/>
				<rule name="String" match="'([^']+)'" replace="~&lt;~~Y~'~&gt;~#&lt;##y#$1#&gt;#~Y~'"/>

				<rule name="Dashes" match="--+" replace="~Y~$0"/>
				<rule name="Headings" match="==+" replace="~C~$0"/>

				<rule name="Numbers" match="(?&lt;=[ {x/(=])-?\d+(?:\.\d+)*" replace="~G~$0"/>

				<rule name="StreamConnecting" test="rtmp stream:.+?Connecting to RTMP" match=".+" replace="%Warn%$0"/>
				<rule name="StreamConnected" test="rtmp stream:.+?Connection to rtmp.+successful" match=".+" replace="~G~$0"/>
				<rule name="StreamDisconnected" test="rtmp stream:.+?Disconnected from rtmp" match=".+" replace="%Fatal%$0"/>
				<rule name="Stream" test="rtmp stream:" match=".+" replace="%Info%$0"/>

				<rule name="WebSocket" test="obs-websocket" match=".+" replace="~M~$0"/>

				<rule
					name="HeadingContent"
					test="===="
					match=" (?:(?&lt;begin&gt;Startup complete)|(?:(?&lt;stream&gt;Streaming )|(?&lt;rec&gt;Recording ))(?:(?&lt;start&gt;Start)|(?&lt;stop&gt;Stop))|(?&lt;end&gt;Shutting down)|(?&lt;prof&gt;Profiler[^=]+)) "
					replace="#c# ~G~${begin}~R~#y#${stream}#m#${rec}#g#~G~${start}#r#~R~${stop}#W#~k~${end}#w#~m~${prof}#c# "
				/>
				<rule name="Tree1" match="┣" replace="~M~+"/>
				<rule name="Tree2" match="┃" replace="~M~|"/>
				<rule name="Tree3" match="┗" replace="~M~\"/>
			</ruleSet>

			<ruleSet name="RFXLog" recordStart="\d\d-...-\d{4} (?:\d\d:){2}\d\d.\d{3}" reset="BookingViewModel is starting up">
				<vars>
					<var name="DateDash" value=""/>
					<var name="DateYear" value="~BLUE~#BLACK#"/>
					<var name="DateMonth" value=""/>
					<var name="DateDay" value=""/>
					<var name="DateSuffixSpace" value=""/>
					<var name="TimeColon" value=""/>
					<var name="TimeHours" value="~CYAN~"/>
					<var name="TimeMins" value=""/>
					<var name="TimeSecs" value="#yellow#"/>
					<var name="TimeDot" value="#BLACK#"/>
					<var name="TimeSecs/10" value="~WHITE~"/>
					<var name="TimeSecs/100" value="#black#"/>
					<var name="TimeSecs/1000" value="~white~"/>
					<var name="TimeSecs/10000" value="~BLACK~"/>

					<var name="Trace" value="~BLACK~"/>
					<var name="Debug" value="~white~"/>
					<var name="Info" value="~WHITE~"/>
					<var name="Warn" value="~YELLOW~"/>
					<var name="Error" value="~RED~"/>
					<var name="Fatal" value="~WHITE~#RED#"/>

					<var name="ClassName" value="#blue#"/>
					<var name="ThreadID" value="#BLUE#"/>

					<var name="ExceptionNamespace" value="~magenta~#black#"/>
					<var name="ExceptionClass" value="~CYAN~#magenta#"/>
					<!-- And the space after it: -->
					<var name="ExceptionColon" value="~white~#yellow#"/>
					<var name="ExceptionMessage" value="~YELLOW~#red#"/>
					<!-- Includes the spaces either side: -->
					<var name="InnerExceptionArrow" value="#black# ~RED~-#BLACK#-#white#-#WHITE#&gt;#black# "/>

					<!-- Includes the spaces either side, as well as the EndOfInnerException marker line: -->
					<var name="StackTraceAt" value="~MAGENTA~#magenta#"/>
					<var name="StackTraceNamespace" value="~BLACK~"/>
					<var name="StackTraceNamespaceDot" value="~white~"/>
					<var name="StackTraceClass" value="~GREEN~"/>
					<var name="StackTraceMember" value="~YELLOW~"/>
					<var name="StackTraceArgsPunctuation" value="~BLUE~"/>
					<var name="StackTraceArgsTypes" value="~cyan~"/>
					<var name="StackTraceArgsNames" value="~yellow~"/>
					<var name="StackTraceDetailsIn" value="~BLACK~"/>
					<var name="StackTraceDetailsPath" value="~green~"/>
					<var name="StackTraceDetailsPathSlash" value="~BLACK~"/>
					<var name="StackTraceDetailsDir" value="~GREEN~"/>
					<var name="StackTraceDetailsFilename" value="~YELLOW~"/>
					<var name="StackTraceDetailsColon" value="~BLACK~"/>
					<var name="StackTraceDetailsLine" value=""/>
					<var name="StackTraceDetailsLineNumber" value="~CYAN~"/>
				</vars>

				<rule
					name="DateTime"
					match="^(\d\d)-(...)-(\d\d\d\d) (\d\d):(\d\d):(\d\d).(\d)(\d)(\d)"
					replace="%DateYear%$3%DateDash%-%DateMonth%$2%DateDash%-%DateDay%$1%DateSuffixSpace% %TimeHours%$4%TimeColon%:%TimeMins%$5%TimeColon%:%TimeSecs%$6%TimeDot%.%TimeSecs/10%$7%TimeSecs/100%$8%TimeSecs/1000%$9"
				/>
				<rule name="ClassName" match="(?&lt;=TID: \d{4} )[^:]+:" replace="%ClassName%$0"/>
				<rule name="ThreadID" match="\bTID: \d{4}(?=\s)" replace="%ThreadID%$0"/>

				<rule
					name="Exception"
					test="Exception\b"
					match="(?x)									# IgnorePatternWhitespace
						(?&lt;namespace&gt;						# Named group 'namespace' is:
							(?:										# ZeroOrMore(greed0:
								(?&gt;									# Atomic group:
									[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
								)
								\.										# '.'
							)*
						)
						(?&lt;class&gt;							# Named group 'class' is:
							\w*										# ZeroOrMore(greedy): Any word character
							Exception								# 'Exception'
							\b										# Zero-width word-boundary assertion.
							[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
						)
						(?&lt;colon&gt;							# Named group 'colon' is:
								\.									# Either: '.'
							|										# Or:
								(?:										# Optional(greedy):
									\ \(0x									# ' (0x'
									[\dA-Fa-f]{8}							# Exactly 8 hex digits
									\)										# ')'
								)?
								:[ ]									# ': '
						)
						(?&lt;message&gt;						# Optional(greedy): Named group 'message' is:
							.+										# OneOrMore(greedy): anything except newlines
						)?
					"
					replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}%ExceptionMessage%${message}"
				>
					<!-- 2 modifications to the same group need unique IDs so we .suffix them: -->
					<group
						name="message.0"
						match="(?x)
							(?&lt;namespace&gt;						# Named group 'namespace' is:
								(?:										# ZeroOrMore(greed0:
									(?&gt;									# Atomic group:
										[\w{}'$]+								# OneOrMore(greedy): Any word character or '{' or '}' or ' or '$'
									)
									\.										# '.'
								)*
							)
							(?&lt;class&gt;							# Named group 'class' is:
								\w*										# ZeroOrMore(greedy): Any word character
								Exception								# 'Exception'
								[^:. ]*									# ZeroOrMore(greedy): Not ':' nor '.' nor ' '
							)
							(?&lt;colon&gt;							# Named group 'colon' is:
									\.									# Either: '.'
								|										# Or:
									(?:										# Optional(greedy):
										\ \(0x									# ' (0x'
										[\dA-Fa-f]{8}							# Exactly 8 hex digits
										\)										# ')'
									)?
									:[ ]									# ': '
							)
						"
						replace="%ExceptionNamespace%${namespace}%ExceptionClass%${class}%ExceptionColon%${colon}"
					/>
					<group name="message.1" match=" ---&gt; " replace="%InnerExceptionArrow%"/>
				</rule>
				<rule name="ExceptionHilight" match="Exception" replace="#M#$0"/>

				<rule
					name="StackTrace"
					test="(?m)(?:^|Current Stack: )   (?:at |--- End of inner)"
					match="(?mx)							# MultiLine, IgnorePatternWhitespace
						(?:^|Current\ Stack:\ )				# StartOfLine or 'Current Stack: '
						(?&lt;at&gt;						# Named group 'at' is:
							\ {3}								# 3 spaces (note that in (?x) mode, significant WS must be escaped)
							(?:									# Either:
									at[ ]							# 'at ' (see above re WS)
								|								# Or:
									---								# '---'
									.+								# OneOrMore(greedy) anything except newlines (i.e. the rest of the line)
							)
						)
						(?:									# Optional(greedy):
							(?&lt;namespace&gt;					# Named group 'namespace' is:
								(?:									# ZeroOrMore(greedy):
									(?&gt;								# Atomic group: (no backtracking into this - all or nothing; used for failing match efficiency)
										[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
									)
									\.									# '.'
								)*
							)
							(?&lt;class&gt;						# Named group 'class' is:
								(?&gt;								# Atomic group:
									[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
								)
								\.									# '.'
							)
							(?&lt;member&gt;					# Named group 'member' is: # Either:
									\.ctor								# '.ctor'
								|									# Or:
									(?&gt;								# Atomic group:
										[^().]+								# OneOrMore(greedy): Not '(' nor ')' nor '.'
									)
							)
							(?&lt;args&gt;						# Named group 'args' is:
								\(									# '('
								(?&gt;								# Atomic group:
									[^)]*								# ZeroOrMore(greedy): Not ')'
								)
								\)									# ')'
							)
							(?&lt;details&gt;					# Optional(greedy): Named group 'details' is:
								\ in[ ]								# ' in '
								.+									# OneOrMore(greedy): anything except newlines
								:line[ ]							# ':line '
								\d+									# OneOrMore(greedy): digits
							)?
						)?
					"
					replace="%StackTraceAt%${at}%StackTraceNamespace%${namespace}%StackTraceClass%${class}%StackTraceMember%${member}%StackTraceArgsPunctuation%${args}${details}"
				>
					<group name="namespace.0" match="^IPFX" replace="~W~$0"/>
					<group name="namespace.1" match="^System" replace="~B~$0"/>
					<group name="namespace.2" match="\." replace="%StackTraceNamespaceDot%."/>
					<group
						name="args"
						match="(?x)								# IgnorePatternWhitespace
							(?&lt;type&gt;						# Named group 'type' is:
								[^(]+?								# OneOrMore(ungreedy): Not '('
							)
							\s									# Whitespace
							(?&lt;name&gt;						# Named group 'name' is:
								[^\s,)]+							# OneOrMore(greedy): Not whitespace nor ',' nor ')'
							)
							(?=									# Followed by (zero-length positive lookahead)
									,								# Either: ','
								|									# Or:
									\)									# ')'
							)
						"
						replace="%StackTraceArgsTypes%${type} %StackTraceArgsNames%${name}"
					/>
					<group
						name="details"
						match="(?x)								# IgnorePatternWhitespace
							in[ ]								# 'in '
							(?&lt;path&gt;						# Named group 'path' is:
								.{4}								# Exactly 4: anything except newlines (to skip over drivename colon complications)
								[^:]+								# OneOrMore(greedy): Not ':'
								[/\\]								# '/' or '\'
							)
							(?&lt;file&gt;						# Named group 'file' is:
								[^/\\:]+							# OneOrMore(greedy): Not: '/' nor '\' nor ':'
							)
							:line[ ]							# ':line '
							(?&lt;line&gt;						# Named group 'line' is:
								\d+									# OneOrMore(greedy): digits
							)
						"
						replace="%StackTraceDetailsIn%in %StackTraceDetailsPath%${path}%StackTraceDetailsFilename%${file}%StackTraceDetailsColon%:%StackTraceDetailsLine%line %StackTraceDetailsLineNumber%${line}"
					>
						<group
							name="path"
							match="(?x)								# IgnorePatternWhitespace
								^									# StartOfLine (in this case, the start of the group's match)
								(?&lt;path&gt;						# Named group 'path' is:
									(?:									# OneOrMore(greedy):
										(?&gt;								# Atomic group:
											[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
										)
										[/\\]								# '/' or '\'
									)+
								)
								(?&lt;dir&gt;						# Named group 'dir' is:
									(?&gt;								# Atomic group:
										[^/\\]+								# OneOrMore(greedy): Not '/' nor '\'
									)
									[/\\]								# '/' or '\'
								)
								$									# EndOfLine (in this case, the end of the group's match)
							"
							replace="${path}%StackTraceDetailsDir%${dir}"
						>
							<group name="path" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
							<group name="dir" match="[/\\]" replace="%StackTraceDetailsPathSlash%$0"/>
						</group>
					</group>
				</rule>

				<rule name="Trace" test="\bTrace\b" match=".+" replace="%Trace%$0"/>
				<rule name="Debug" test="\bDebug\b" match=".+" replace="%Debug%$0"/>
				<rule name="Info" test="\bInfo\b" match=".+" replace="%Info%$0"/>
				<rule name="Warn" test="\bWarning\b" match=".+" replace="%Warn%$0"/>
				<rule name="Error" test="\bError\b" match=".+" replace="%Error%$0"/>
				<rule name="Fatal" test="\bFatal\b" match=".+" replace="%Fatal%$0"/>
			</ruleSet>

			<ruleSet name="gitOverview" recordStart="/cygdrive">
				<vars>
					<var name="PathPrefix" value="~K~"/>
					<var name="Repo" value="~W~"/>
					<var name="Branch" value="~G~"/>
					<var name="Master" value="#c#"/>
					<var name="State" value="~R~"/>
					<var name="PathWithState" value="~r~"/>
					<var name="StateRename" value="~G~"/>
					<var name="PathWithStateRename" value="~g~"/>
					<var name="StateDelete" value="~Y~"/>
					<var name="PathWithStateDelete" value="~y~"/>
					<var name="PathWithoutState" value="~m~"/>
					<var name="Changes" value="~B~"/>
					<var name="NotStaged" value="~C~"/>
					<var name="ToCommit" value="~Y~"/>
					<var name="Ahead" value="#g#~G~"/>
					<var name="Behind" value="#r#~R~"/>
					<var name="Of" value="#y#~C~"/>
					<var name="FastForward" value="#B#~G~"/>
				</vars>

				<rule name="1.path" match="(?s)^(/[^\s]+/)([^/\s]+) (.+)" replace="%PathPrefix%$1%Repo%$2\n\t\t$3">
					<group name="3.CR" match="\r" replace=""/>
					<group name="3.~" match="~+" replace=""/>
					<group name="3.eat" match="(?m)^( |Your branch is up to date with|nothing to commit|no changes added|Untracked).+" replace=""/>
					<group name="3.ahead" match="\nYour branch is ahead of '([^']+)' by (\d+) commit.+\n" replace="\t\t%Ahead%^$2#!# %Of%$1"/>
					<group name="3.behind" match="\nYour branch is behind '([^']+)' by (\d+) commit(.+)\n" replace="\t\t%Behind%v$2#!# %Of%$1#!#$3">
						<group name="3.fastForward" match="^.+$" replace="$0">
							<group name="0.noFF" match="^(?!.+?fast-forward).+" replace=""/>
							<group name="0.shorter" match="^.+fast-forward.+$" replace="\t%FastForward%FF"/>
						</group>
					</group>
					<group name="3.diverged" match="\nYour branch and '([^']+)' have diverged,\nand have (\d+) and (\d+).+\n" replace="\t\t%Ahead%^$2%Behind%v$3#!# %Of%$1"/>
					<group name="3.renamed" match="(?m)^(\trenamed:\s+)(.+)" replace="%StateRename%$1%PathWithStateRename%$2"/>
					<group name="3.deleted" match="(?m)^(\tdeleted:\s+)(.+)" replace="%StateDelete%$1%PathWithStateDelete%$2"/>
					<group name="3.modified" match="(?m)^(\t[^:]+:\s+)(.+)" replace="%State%$1%PathWithState%$2"/>
					<group name="3.additions" match="(?m)^\t[^:\n]+$" replace="%PathWithoutState%$0"/>
					<group name="3.branch" match="\nOn branch (.+)" replace="%Branch%$1">
						<group name="1.master" match="master" replace="%Master%$0"/>
					</group>
					<group name="3.LF" match="(?m)^\s*\n(?:\s*\n)+" replace=""/>
					<group name="3.changes" match="\n+Changes (.+)\n+" replace="\n%Changes%$1\n">
						<group name="1.NotStaged" match="not staged" replace="\t%NotStaged%$0"/>
						<group name="1.ToCommit" match="to be committed" replace="\t%ToCommit%$0"/>
					</group>
				</rule>
			</ruleSet>

			<ruleSet name="RAW">
				<rule name="all" match=".*" replace="~M~RAW:~W~$0"/>
			</ruleSet>
		</ruleSets>
	</logConfig>
</configuration>
